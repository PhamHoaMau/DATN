CCS PCD C Compiler, Version 5.025, 63819               27-Oct-20 10:34

               Filename:   C:\Users\Admin\Desktop\jwclab\station\iot_station\1_Demo_station\3_Code\6_Code_merged\Main\main.lst

               ROM used:   8886 bytes (9%)
                           Largest free fragment is 56650
               RAM used:   337 (4%) at main() level
                           1163 (14%) worst case
               Stack used: 62 locations
               Stack size: 128

*
00000:  GOTO    2084
.................... //*************Khai bao thu vien*************** 
.................... #include <main.h> 
.................... #include <30F6014.h> 
.................... //////////// Standard Header file for the DSPIC30F6014 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device DSPIC30F6014 
*
00100:  CLR     32
00102:  MOV     #10C,W3
00104:  ADD     W3,W0,W0
00106:  TBLRDL.B[W0],W0L
00108:  CLR.B   1
0010A:  RETURN  
0010C:  DATA    41,54,00
0010E:  DATA    2B,43,00
00110:  DATA    49,50,00
00112:  DATA    43,4C,00
00114:  DATA    4F,53,00
00116:  DATA    45,00,00
00118:  CLR     32
0011A:  MOV     #124,W3
0011C:  ADD     W3,W0,W0
0011E:  TBLRDL.B[W0],W0L
00120:  CLR.B   1
00122:  RETURN  
00124:  DATA    41,54,00
00126:  DATA    2B,43,00
00128:  DATA    52,45,00
0012A:  DATA    47,3F,00
0012C:  DATA    00,00,00
0012E:  CLR     32
00130:  MOV     #13A,W3
00132:  ADD     W3,W0,W0
00134:  TBLRDL.B[W0],W0L
00136:  CLR.B   1
00138:  RETURN  
0013A:  DATA    41,54,00
0013C:  DATA    2B,43,00
0013E:  DATA    47,41,00
00140:  DATA    54,54,00
00142:  DATA    3F,00,00
00144:  CLR     32
00146:  MOV     #150,W3
00148:  ADD     W3,W0,W0
0014A:  TBLRDL.B[W0],W0L
0014C:  CLR.B   1
0014E:  RETURN  
00150:  DATA    41,54,00
00152:  DATA    2B,43,00
00154:  DATA    49,50,00
00156:  DATA    53,48,00
00158:  DATA    55,54,00
0015A:  DATA    00,00,00
0015C:  CLR     32
0015E:  MOV     #168,W3
00160:  ADD     W3,W0,W0
00162:  TBLRDL.B[W0],W0L
00164:  CLR.B   1
00166:  RETURN  
00168:  DATA    41,54,00
0016A:  DATA    2B,43,00
0016C:  DATA    53,54,00
0016E:  DATA    54,3D,00
00170:  DATA    22,77,00
00172:  DATA    77,77,00
00174:  DATA    22,2C,00
00176:  DATA    22,22,00
00178:  DATA    2C,22,00
0017A:  DATA    22,20,00
0017C:  DATA    00,00,00
0017E:  CLR     32
00180:  MOV     #18A,W3
00182:  ADD     W3,W0,W0
00184:  TBLRDL.B[W0],W0L
00186:  CLR.B   1
00188:  RETURN  
0018A:  DATA    41,54,00
0018C:  DATA    2B,43,00
0018E:  DATA    49,49,00
00190:  DATA    43,52,00
00192:  DATA    00,00,00
00194:  CLR     32
00196:  MOV     #1A0,W3
00198:  ADD     W3,W0,W0
0019A:  TBLRDL.B[W0],W0L
0019C:  CLR.B   1
0019E:  RETURN  
001A0:  DATA    41,54,00
001A2:  DATA    20,2B,00
001A4:  DATA    43,49,00
001A6:  DATA    46,53,00
001A8:  DATA    52,00,00
001AA:  CLR     32
001AC:  MOV     #1B6,W3
001AE:  ADD     W3,W0,W0
001B0:  TBLRDL.B[W0],W0L
001B2:  CLR.B   1
001B4:  RETURN  
001B6:  DATA    41,54,00
001B8:  DATA    2B,43,00
001BA:  DATA    49,50,00
001BC:  DATA    53,54,00
001BE:  DATA    41,52,00
001C0:  DATA    54,3D,00
001C2:  DATA    22,54,00
001C4:  DATA    43,50,00
001C6:  DATA    22,2C,00
001C8:  DATA    22,25,00
001CA:  DATA    73,22,00
001CC:  DATA    2C,22,00
001CE:  DATA    25,73,00
001D0:  DATA    22,00,00
001D2:  CLR     32
001D4:  MOV     #1DE,W3
001D6:  ADD     W3,W0,W0
001D8:  TBLRDL.B[W0],W0L
001DA:  CLR.B   1
001DC:  RETURN  
001DE:  DATA    6D,71,00
001E0:  DATA    74,74,00
001E2:  DATA    2E,6A,00
001E4:  DATA    77,63,00
001E6:  DATA    6C,61,00
001E8:  DATA    62,2E,00
001EA:  DATA    63,6F,00
001EC:  DATA    6D,00,00
001EE:  CLR     32
001F0:  MOV     #1FA,W3
001F2:  ADD     W3,W0,W0
001F4:  TBLRDL.B[W0],W0L
001F6:  CLR.B   1
001F8:  RETURN  
001FA:  DATA    31,38,00
001FC:  DATA    38,33,00
001FE:  DATA    00,00,00
00200:  CLR     32
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    41,54,00
0020E:  DATA    2B,43,00
00210:  DATA    49,50,00
00212:  DATA    53,45,00
00214:  DATA    4E,44,00
00216:  DATA    3B,00,00
00218:  CLR     32
0021A:  MOV     #224,W3
0021C:  ADD     W3,W0,W0
0021E:  TBLRDL.B[W0],W0L
00220:  CLR.B   1
00222:  RETURN  
00224:  DATA    4D,51,00
00226:  DATA    54,54,00
00228:  DATA    00,00,00
0022A:  CLR     32
0022C:  MOV     #236,W3
0022E:  ADD     W3,W0,W0
00230:  TBLRDL.B[W0],W0L
00232:  CLR.B   1
00234:  RETURN  
00236:  DATA    41,42,00
00238:  DATA    43,44,00
0023A:  DATA    45,46,00
0023C:  DATA    00,00,00
0023E:  CLR     32
00240:  MOV     #32,W3
00242:  SUB     W0,W3,W3
00244:  BRA     C,250
00246:  MOV     #25A,W3
00248:  ADD     W3,W0,W0
0024A:  TBLRDL.B[W0],W0L
0024C:  CLR.B   1
0024E:  RETURN  
00250:  MOV     #25A,W0
00252:  ADD     W3,W3,W3
00254:  ADD     W3,W0,W3
00256:  TBLRDH  [W3],W0
00258:  RETURN  
0025A:  DATA    25,73,56
0025C:  DATA    7B,22,22
0025E:  DATA    44,45,3A
00260:  DATA    56,49,25
00262:  DATA    43,45,66
00264:  DATA    5F,49,2C
00266:  DATA    44,22,22
00268:  DATA    3A,22,44
0026A:  DATA    64,65,55
0026C:  DATA    6D,6F,53
0026E:  DATA    5F,73,54
00270:  DATA    74,61,22
00272:  DATA    74,69,3A
00274:  DATA    6F,6E,25
00276:  DATA    22,2C,66
00278:  DATA    22,54,2C
0027A:  DATA    4D,50,22
0027C:  DATA    22,3A,50
0027E:  DATA    25,66,48
00280:  DATA    2C,22,22
00282:  DATA    48,55,3A
00284:  DATA    4D,22,25
00286:  DATA    3A,25,66
00288:  DATA    66,2C,7D
0028A:  DATA    22,55,00
0028C:  CLR     32
0028E:  MOV     #298,W3
00290:  ADD     W3,W0,W0
00292:  TBLRDL.B[W0],W0L
00294:  CLR.B   1
00296:  RETURN  
00298:  DATA    6A,77,00
0029A:  DATA    63,6C,00
0029C:  DATA    61,62,00
0029E:  DATA    2F,64,00
002A0:  DATA    65,6D,00
002A2:  DATA    6F,5F,00
002A4:  DATA    73,74,00
002A6:  DATA    61,74,00
002A8:  DATA    69,6F,00
002AA:  DATA    6E,00,00
002AC:  CLR     32
002AE:  MOV     #2B8,W3
002B0:  ADD     W3,W0,W0
002B2:  TBLRDL.B[W0],W0L
002B4:  CLR.B   1
002B6:  RETURN  
002B8:  DATA    3D,3D,00
002BA:  DATA    3D,3D,00
002BC:  DATA    3D,3D,00
002BE:  DATA    3D,4A,00
002C0:  DATA    57,43,00
002C2:  DATA    4C,41,00
002C4:  DATA    42,20,00
002C6:  DATA    53,54,00
002C8:  DATA    41,52,00
002CA:  DATA    54,3D,00
002CC:  DATA    3D,3D,00
002CE:  DATA    3D,3D,00
002D0:  DATA    3D,3D,00
002D2:  DATA    3D,00,00
002D4:  CLR     32
002D6:  MOV     #2E0,W3
002D8:  ADD     W3,W0,W0
002DA:  TBLRDL.B[W0],W0L
002DC:  CLR.B   1
002DE:  RETURN  
002E0:  DATA    3D,3D,00
002E2:  DATA    3D,3D,00
002E4:  DATA    3D,3D,00
002E6:  DATA    3D,4A,00
002E8:  DATA    57,43,00
002EA:  DATA    4C,41,00
002EC:  DATA    42,20,00
002EE:  DATA    43,4F,00
002F0:  DATA    4E,4E,00
002F2:  DATA    45,43,00
002F4:  DATA    54,20,00
002F6:  DATA    42,52,00
002F8:  DATA    4F,4B,00
002FA:  DATA    45,52,00
002FC:  DATA    3D,3D,00
002FE:  DATA    3D,3D,00
00300:  DATA    3D,3D,00
00302:  DATA    3D,3D,00
00304:  DATA    00,00,00
00306:  CLR     32
00308:  MOV     #312,W3
0030A:  ADD     W3,W0,W0
0030C:  TBLRDL.B[W0],W0L
0030E:  CLR.B   1
00310:  RETURN  
00312:  DATA    3D,3D,00
00314:  DATA    3D,3D,00
00316:  DATA    3D,3D,00
00318:  DATA    3D,4A,00
0031A:  DATA    57,43,00
0031C:  DATA    4C,41,00
0031E:  DATA    42,20,00
00320:  DATA    53,45,00
00322:  DATA    4E,44,00
00324:  DATA    20,44,00
00326:  DATA    41,54,00
00328:  DATA    41,20,00
0032A:  DATA    42,52,00
0032C:  DATA    4F,4B,00
0032E:  DATA    45,52,00
00330:  DATA    3D,3D,00
00332:  DATA    3D,3D,00
00334:  DATA    3D,3D,00
00336:  DATA    3D,3D,00
00338:  DATA    00,00,00
0033A:  CLR     32
0033C:  MOV     #346,W3
0033E:  ADD     W3,W0,W0
00340:  TBLRDL.B[W0],W0L
00342:  CLR.B   1
00344:  RETURN  
00346:  DATA    3D,3D,00
00348:  DATA    3D,3D,00
0034A:  DATA    3D,3D,00
0034C:  DATA    3D,4A,00
0034E:  DATA    57,43,00
00350:  DATA    4C,41,00
00352:  DATA    42,20,00
00354:  DATA    43,4C,00
00356:  DATA    4F,53,00
00358:  DATA    45,20,00
0035A:  DATA    42,52,00
0035C:  DATA    4F,4B,00
0035E:  DATA    45,52,00
00360:  DATA    3D,3D,00
00362:  DATA    3D,3D,00
00364:  DATA    3D,3D,00
00366:  DATA    3D,3D,00
00368:  DATA    00,00,00
*
004F2:  MOV     W1,[W15++]
004F4:  MOV     8D0,W1
004F6:  MOV.B   W0L,[W1++]
004F8:  CLR.B   [W1]
004FA:  MOV     [--W15],W1
004FC:  INC     08D0
004FE:  RETURN  
*
00714:  MOV     W5,[W15++]
00716:  MOV     #C,W5
00718:  REPEAT  #3
0071A:  MOV     [W5++],[W15++]
0071C:  MOV     W0,W4
0071E:  MOV     W1,W5
00720:  MOV     W2,W6
00722:  MOV     W3,W7
00724:  CLR     W0
00726:  CLR     W1
00728:  CLR     W2
0072A:  CLR     W3
0072C:  BCLR    W8.0
0072E:  BTSS    W7.F
00730:  BRA     73C
00732:  BSET    W8.0
00734:  NEG     W4,W4
00736:  COM     W5,W5
00738:  COM     W6,W6
0073A:  COM     W7,W7
0073C:  IOR      W4,  W5,W9
0073E:  BRA     NZ,744
00740:  IOR      W6,  W7,W9
00742:  BRA     Z,76E
00744:  MOV     #473,W9
00746:  BTSC    W3.4
00748:  BRA     760
0074A:  BCLR.B  42.0
0074C:  RLC     W4,W4
0074E:  RLC     W5,W5
00750:  RLC     W6,W6
00752:  RLC     W7,W7
00754:  RLC     W0,W0
00756:  RLC     W1,W1
00758:  RLC     W2,W2
0075A:  RLC     W3,W3
0075C:  DEC     W9,W9
0075E:  BRA     NZ,746
00760:  SL      W9,#4,W9
00762:  BCLR.B  42.0
00764:  BCLR    W9.F
00766:  BCLR    W3.4
00768:  XOR     W9,W3,W3
0076A:  BTSC    W8.0
0076C:  BSET    W3.F
0076E:  MOV     #12,W5
00770:  REPEAT  #3
00772:  MOV     [--W15],[W5--]
00774:  MOV     [--W15],W5
00776:  RETURN  
00778:  MOV     W8,[W15++]
0077A:  MOV     #12,W8
0077C:  REPEAT  #4
0077E:  MOV     [W8++],[W15++]
00780:  CLR     W11
00782:  MUL.UU  W12,#0,W12
00784:  MOV     W3,W8
00786:  MOV     W7,W9
00788:  MOV     #7FF,W10
0078A:  BCLR.B  42.0
0078C:  BCLR.B  42.1
0078E:  ASR     W8,#4,W8
00790:  AND     W10,W8,W8
00792:  CP0     W8
00794:  BRA     Z,878
00796:  BCLR.B  42.0
00798:  BCLR.B  42.1
0079A:  ASR     W9,#4,W9
0079C:  AND     W10,W9,W9
0079E:  CP0     W9
007A0:  BRA     Z,878
007A2:  ADD     W9,W8,W8
007A4:  BTSC    W9.B
007A6:  BRA     7B0
007A8:  SUB     #3FF,W8
007AA:  BRA     Z,878
007AC:  BRA     NC,878
007AE:  BRA     7B6
007B0:  MOV     #401,W10
007B2:  ADD.B   W10L,W5L,W5L
007B4:  BRA     C,878
007B6:  XOR     W3,W7,W13
007B8:  BCLR.B  42.0
007BA:  BCLR.B  42.1
007BC:  AND     #F,W3
007BE:  BSET    W3.4
007C0:  AND     #F,W7
007C2:  BSET    W7.4
007C4:  MOV     W8,[W15++]
007C6:  MUL.UU  W4,W1,W8
007C8:  MUL.UU  W5,W0,W10
007CA:  ADD     W8,W10,W10
007CC:  ADDC    W9,W11,W11
007CE:  ADDC    #0,W12
007D0:  MUL.UU  W4,W2,W8
007D2:  ADD     W8,W11,W11
007D4:  ADDC    W9,W12,W12
007D6:  MUL.UU  W5,W1,W8
007D8:  CLR     W10
007DA:  ADD     W8,W11,W11
007DC:  ADDC    W9,W12,W12
007DE:  ADDC    #0,W10
007E0:  MUL.UU  W6,W0,W8
007E2:  ADD     W8,W11,W11
007E4:  ADDC    W9,W12,W12
007E6:  ADDC    #0,W10
007E8:  CLR     W11
007EA:  MUL.UU  W4,W3,W8
007EC:  ADD     W8,W12,W12
007EE:  ADDC    W9,W10,W10
007F0:  ADDC    #0,W11
007F2:  MUL.UU  W5,W2,W8
007F4:  ADD     W8,W12,W12
007F6:  ADDC    W9,W10,W10
007F8:  ADDC    #0,W11
007FA:  MUL.UU  W6,W1,W8
007FC:  ADD     W8,W12,W12
007FE:  ADDC    W9,W10,W10
00800:  ADDC    #0,W11
00802:  MUL.UU  W7,W0,W8
00804:  ADD     W8,W12,W12
00806:  ADDC    W9,W10,W10
00808:  ADDC    #0,W11
0080A:  MOV     W12,W0
0080C:  CLR     W12
0080E:  MUL.UU  W5,W3,W8
00810:  ADD     W8,W10,W10
00812:  ADDC    W9,W11,W11
00814:  ADDC    #0,W12
00816:  MUL.UU  W6,W2,W8
00818:  ADD     W8,W10,W10
0081A:  ADDC    W9,W11,W11
0081C:  ADDC    #0,W12
0081E:  MUL.UU  W6,W3,W8
00820:  ADD     W8,W11,W11
00822:  ADDC    W9,W12,W12
00824:  MUL.UU  W7,W1,W8
00826:  ADD     W8,W10,W10
00828:  ADDC    W9,W11,W11
0082A:  ADDC    #0,W12
0082C:  MUL.UU  W7,W2,W8
0082E:  ADD     W8,W11,W11
00830:  ADDC    W9,W12,W12
00832:  MUL.UU  W7,W3,W8
00834:  ADD     W8,W12,W12
00836:  MOV     W10,W1
00838:  MOV     W11,W2
0083A:  MOV     W12,W3
0083C:  MOV     #5,W4
0083E:  BCLR.B  42.0
00840:  RRC     W3,W3
00842:  RRC     W2,W2
00844:  RRC     W1,W1
00846:  RRC     W0,W0
00848:  DEC     W4,W4
0084A:  BRA     NZ,83E
0084C:  MOV     [--W15],W8
0084E:  INC     W8,W8
00850:  IOR      W0,  W1,W6
00852:  BRA     Z,856
00854:  BRA     85A
00856:  IOR      W2,  W3,W6
00858:  BRA     Z,86A
0085A:  BTSC    W3.4
0085C:  BRA     86A
0085E:  BCLR.B  42.0
00860:  RLC     W0,W0
00862:  RLC     W1,W1
00864:  RLC     W2,W2
00866:  RLC     W3,W3
00868:  DEC     W8,W8
0086A:  SL      W8,#4,W8
0086C:  BCLR    W3.F
0086E:  BTSC    W13.F
00870:  BSET    W3.F
00872:  BCLR    W3.4
00874:  XOR     W8,W3,W3
00876:  BRA     87E
00878:  MUL.UU  W0,#0,W0
0087A:  MUL.UU  W0,#0,W2
0087C:  BRA     87E
0087E:  MOV     #1A,W8
00880:  REPEAT  #4
00882:  MOV     [--W15],[W8--]
00884:  MOV     [--W15],W8
00886:  RETURN  
00888:  MOV     W8,[W15++]
0088A:  MOV     #12,W8
0088C:  REPEAT  #4
0088E:  MOV     [W8++],[W15++]
00890:  XOR     W3,W7,W13
00892:  MOV     W3,W8
00894:  MOV     W7,W9
00896:  MOV     #7FF,W10
00898:  BCLR.B  42.0
0089A:  BCLR.B  42.1
0089C:  ASR     W8,#4,W8
0089E:  AND     W10,W8,W8
008A0:  CP0     W8
008A2:  BRA     Z,97C
008A4:  BCLR.B  42.0
008A6:  BCLR.B  42.1
008A8:  ASR     W9,#4,W9
008AA:  AND     W10,W9,W9
008AC:  CP0     W9
008AE:  BRA     Z,97C
008B0:  CLR     W10
008B2:  SUB     W8,W9,W12
008B4:  BRA     NC,8BC
008B6:  ADD     #3FF,W12
008B8:  BRA     C,97C
008BA:  BRA     8C4
008BC:  MOV     #401,W11
008BE:  SUB     W12,W11,W12
008C0:  BRA     NC,97C
008C2:  BRA     Z,97C
008C4:  CLR     W8
008C6:  CLR     W9
008C8:  CLR     W10
008CA:  CLR     W11
008CC:  AND     #1F,W3
008CE:  BSET    W3.4
008D0:  AND     #1F,W7
008D2:  BSET    W7.4
008D4:  MOV     W12,[W15++]
008D6:  MOV     #36,W12
008D8:  SUB     W0,W4,W0
008DA:  SUBB    W1,W5,W1
008DC:  SUBB    W2,W6,W2
008DE:  SUBB    W3,W7,W3
008E0:  BRA     N,8E6
008E2:  BRA     C,8F0
008E4:  BRA     NZ,8F2
008E6:  ADD     W0,W4,W0
008E8:  ADDC    W1,W5,W1
008EA:  ADDC    W2,W6,W2
008EC:  ADDC    W3,W7,W3
008EE:  BRA     8F2
008F0:  BSET    W8.0
008F2:  DEC     W12,W12
008F4:  BRA     Z,90C
008F6:  BCLR.B  42.0
008F8:  RLC     W0,W0
008FA:  RLC     W1,W1
008FC:  RLC     W2,W2
008FE:  RLC     W3,W3
00900:  BCLR.B  42.0
00902:  RLC     W8,W8
00904:  RLC     W9,W9
00906:  RLC     W10,W10
00908:  RLC     W11,W11
0090A:  BRA     8D8
0090C:  MOV     [--W15],W12
0090E:  BTSC    W11.5
00910:  BRA     914
00912:  BRA     920
00914:  BCLR.B  42.0
00916:  RRC     W11,W11
00918:  RRC     W10,W10
0091A:  RRC     W9,W9
0091C:  RRC     W8,W8
0091E:  BRA     926
00920:  DEC     W12,W12
00922:  BCLR.B  42.0
00924:  BRA     Z,97C
00926:  BTSC.B  42.0
00928:  BRA     93C
0092A:  RLC     W0,W0
0092C:  RLC     W1,W1
0092E:  RLC     W2,W2
00930:  RLC     W3,W3
00932:  SUB     W0,W4,W4
00934:  SUBB    W1,W5,W5
00936:  SUBB    W2,W6,W6
00938:  SUBB    W3,W7,W7
0093A:  BRA     NC,966
0093C:  INC     W8,W8
0093E:  BRA     NZ,966
00940:  INC     W9,W9
00942:  BRA     NZ,966
00944:  INC     W10,W10
00946:  BRA     NZ,966
00948:  INC     W11,W11
0094A:  BRA     NZ,966
0094C:  INC     W12,W12
0094E:  BRA     Z,97C
00950:  BRA     966
00952:  DEC     W12,W12
00954:  BRA     Z,97C
00956:  BTSC    W11.4
00958:  BRA     966
0095A:  BCLR.B  42.0
0095C:  RLC     W8,W8
0095E:  RLC     W9,W9
00960:  RLC     W10,W10
00962:  RLC     W11,W11
00964:  BRA     956
00966:  SL      W12,#4,W12
00968:  BCLR.B  42.0
0096A:  BCLR    W12.F
0096C:  BTSC    W13.F
0096E:  BSET    W12.F
00970:  BCLR    W11.4
00972:  XOR     W12,W11,W3
00974:  MOV     W10,W2
00976:  MOV     W9,W1
00978:  MOV     W8,W0
0097A:  BRA     986
0097C:  MOV     #0,W0
0097E:  MOV     #0,W1
00980:  MOV     #0,W2
00982:  MOV     #0,W3
00984:  BRA     986
00986:  MOV     #1A,W8
00988:  REPEAT  #4
0098A:  MOV     [--W15],[W8--]
0098C:  MOV     [--W15],W8
0098E:  RETURN  
00990:  MOV     W5,[W15++]
00992:  MOV     W6,[W15++]
00994:  MOV     W3,W4
00996:  MOV     W3,W6
00998:  BCLR.B  42.0
0099A:  ASR     W4,#4,W4
0099C:  MOV     #7FF,W5
0099E:  AND     W5,W4,W4
009A0:  BRA     NZ,9A8
009A2:  MUL.UU  W0,#0,W0
009A4:  CLR     W2
009A6:  BRA     9CE
009A8:  SUB     #380,W4
009AA:  AND     #F,W3
009AC:  MOV     #3,W7
009AE:  BCLR.B  42.0
009B0:  RLC     W0,W0
009B2:  RLC     W1,W1
009B4:  RLC     W2,W2
009B6:  RLC     W3,W3
009B8:  DEC     W7,W7
009BA:  BRA     NZ,9AE
009BC:  MOV     W1,W0
009BE:  MOV     W2,W1
009C0:  BCLR    W3.7
009C2:  SWAP    W4
009C4:  BCLR.B  42.0
009C6:  RRC     W4,W4
009C8:  BTSC    W6.F
009CA:  BSET    W4.F
009CC:  XOR     W4,W3,W2
009CE:  MOV     [--W15],W6
009D0:  MOV     [--W15],W5
009D2:  RETURN  
009D4:  MOV     W5,[W15++]
009D6:  MOV     W6,[W15++]
009D8:  MOV     W7,[W15++]
009DA:  XOR     W1,W3,W4
009DC:  BTSS    W4.F
009DE:  BRA     9EC
009E0:  BCLR.B  42.0
009E2:  BCLR.B  42.1
009E4:  BTSS    W1.F
009E6:  BRA     A34
009E8:  BSET.B  42.0
009EA:  BRA     A34
009EC:  MOV     W1,W4
009EE:  MOV     W0,W5
009F0:  MOV     W3,W6
009F2:  MOV     W2,W7
009F4:  RLC     W1,W1
009F6:  SWAP    W1
009F8:  RLC     W3,W3
009FA:  SWAP    W3
009FC:  SUB.B   W3L,W1L,W1L
009FE:  BRA     Z,A0A
00A00:  BTSS    W4.F
00A02:  BRA     A34
00A04:  MOV     #1,W0
00A06:  XOR.B   42
00A08:  BRA     A34
00A0A:  MOV.B   W4L,W1L
00A0C:  MOV.B   W6L,W3L
00A0E:  BCLR    W1.7
00A10:  BCLR    W3.7
00A12:  SUB.B   W3L,W1L,W1L
00A14:  BRA     Z,A20
00A16:  BTSS    W4.F
00A18:  BRA     A34
00A1A:  MOV     #1,W0
00A1C:  XOR.B   42
00A1E:  BRA     A34
00A20:  SUB     W7,W5,W1
00A22:  BRA     Z,A2E
00A24:  BTSS    W4.F
00A26:  BRA     A34
00A28:  MOV     #1,W0
00A2A:  XOR.B   42
00A2C:  BRA     A34
00A2E:  BCLR.B  42.0
00A30:  BRA     A34
00A32:  BRA     A34
00A34:  MOV     [--W15],W7
00A36:  MOV     [--W15],W6
00A38:  MOV     [--W15],W5
00A3A:  RETURN  
00A3C:  MOV     W0,W2
00A3E:  MOV     W1,W3
00A40:  MOV.B   W1L,W0L
00A42:  SWAP    W0
00A44:  BSET    W0.F
00A46:  RLC     W1,W1
00A48:  SWAP    W1
00A4A:  ZE      W1,W1
00A4C:  MOV     #8E,W4
00A4E:  SUB.B   W4L,W1L,W1L
00A50:  BRA     Z,A5E
00A52:  CP0     W0
00A54:  BRA     Z,A5E
00A56:  BCLR.B  42.0
00A58:  RRC     W0,W0
00A5A:  DEC     W1,W1
00A5C:  BRA     NZ,A52
00A5E:  BTSS    W3.F
00A60:  BRA     A66
00A62:  NEG     W0,W0
00A64:  BRA     A66
00A66:  RETURN  
00A68:  MOV     W5,[W15++]
00A6A:  MOV     W6,[W15++]
00A6C:  MOV     #8E,W1
00A6E:  CP0     W0
00A70:  BRA     Z,A96
00A72:  BTSC    W0.F
00A74:  BRA     A7E
00A76:  BCLR.B  42.0
00A78:  RLC     W0,W0
00A7A:  DEC     W1,W1
00A7C:  BRA     A72
00A7E:  SWAP    W1
00A80:  BCLR.B  42.0
00A82:  RRC     W1,W1
00A84:  BCLR    W0.F
00A86:  SWAP    W0
00A88:  XOR.B   W0L,W1L,W1L
00A8A:  AND.B   #0,W0L
00A8C:  BRA     A9C
00A8E:  MOV.B   W1L,W0L
00A90:  BSET    W1.7
00A92:  AND.B   #0,W1L
00A94:  BRA     A9C
00A96:  CLR     W0
00A98:  CLR     W1
00A9A:  BRA     A9C
00A9C:  MOV     [--W15],W6
00A9E:  MOV     [--W15],W5
00AA0:  RETURN  
00AA2:  MOV     W5,[W15++]
00AA4:  MOV     #C,W5
00AA6:  REPEAT  #4
00AA8:  MOV     [W5++],[W15++]
00AAA:  MOV     W0,W4
00AAC:  MOV     W1,W5
00AAE:  MOV     W3,W7
00AB0:  MOV     W2,W6
00AB2:  BCLR.B  42.0
00AB4:  BCLR.B  42.1
00AB6:  RLC     W1,W1
00AB8:  SWAP    W1
00ABA:  AND     #FF,W1
00ABC:  CP0     W1
00ABE:  BRA     Z,B56
00AC0:  BCLR.B  42.0
00AC2:  BCLR.B  42.1
00AC4:  RLC     W3,W3
00AC6:  SWAP    W3
00AC8:  AND     #FF,W3
00ACA:  CP0     W3
00ACC:  BRA     Z,B56
00ACE:  ZE      W0,W0
00AD0:  ADD.B   W3L,W1L,W0L
00AD2:  BRA     C,ADC
00AD4:  SUB     #7F,W0
00AD6:  BRA     Z,B56
00AD8:  BRA     NC,B56
00ADA:  BRA     AE0
00ADC:  ADD.B   #81,W0L
00ADE:  BRA     C,B56
00AE0:  XOR     W5,W7,W10
00AE2:  BCLR.B  42.0
00AE4:  BCLR.B  42.1
00AE6:  AND     #FF,W5
00AE8:  BSET    W5.7
00AEA:  BCLR.B  42.0
00AEC:  AND     #FF,W7
00AEE:  BSET    W7.7
00AF0:  MUL.UU  W4,W6,W2
00AF2:  MUL.UU  W5,W6,W8
00AF4:  ADDC    W8,W3,W3
00AF6:  MOV     W9,W1
00AF8:  BTSC.B  42.0
00AFA:  INC     W1,W1
00AFC:  BCLR.B  42.0
00AFE:  MUL.UU  W7,W4,W8
00B00:  ADDC    W8,W3,W3
00B02:  ADDC    W9,W1,W1
00B04:  MUL.UU  W5,W7,W8
00B06:  ADDC    W8,W1,W1
00B08:  INC     W0,W0
00B0A:  CP0     W1
00B0C:  BTSC.B  42.1
00B0E:  BRA     B12
00B10:  BRA     B18
00B12:  CP0     W3
00B14:  BTSC.B  42.1
00B16:  BRA     B22
00B18:  BTSC    W1.F
00B1A:  BRA     B22
00B1C:  RLC     W3,W3
00B1E:  RLC     W1,W1
00B20:  DEC     W0,W0
00B22:  MOV     W1,W2
00B24:  BCLR.B  42.0
00B26:  BTSS    W3.7
00B28:  BRA     B3C
00B2A:  MOV     #FF00,W7
00B2C:  AND     W3,W7,W3
00B2E:  ADD     #100,W3
00B30:  ADDC    W2,#0,W2
00B32:  CP0     W2
00B34:  BRA     NZ,B3C
00B36:  CP0     W3
00B38:  BRA     NZ,B3C
00B3A:  INC     W0,W0
00B3C:  SWAP    W0
00B3E:  BCLR.B  42.0
00B40:  BCLR.B  42.1
00B42:  RRC     W0,W1
00B44:  BTSC    W10.F
00B46:  BSET    W1.F
00B48:  BCLR    W2.F
00B4A:  SWAP    W2
00B4C:  XOR.B   W2L,W1L,W1L
00B4E:  SWAP    W3
00B50:  MOV.B   W3L,W2L
00B52:  MOV     W2,W0
00B54:  BRA     B5C
00B56:  MOV     #0,W0
00B58:  MOV     #0,W1
00B5A:  BRA     B5C
00B5C:  MOV     #14,W5
00B5E:  REPEAT  #4
00B60:  MOV     [--W15],[W5--]
00B62:  MOV     [--W15],W5
00B64:  RETURN  
00B66:  MOV     W5,[W15++]
00B68:  MOV     #C,W5
00B6A:  REPEAT  #3
00B6C:  MOV     [W5++],[W15++]
00B6E:  CLR     W9
00B70:  MOV     #8000,W8
00B72:  BTSC.B  43.0
00B74:  XOR     W8,W3,W3
00B76:  CP0     W0
00B78:  BRA     NZ,B80
00B7A:  MOV     #7FFF,W10
00B7C:  AND     W1,W10,W10
00B7E:  BTSS.B  42.1
00B80:  MOV     W1,W10
00B82:  XOR     W3,W10,W11
00B84:  MOV     W1,W6
00B86:  MOV     W3,W7
00B88:  MOV     W3,W12
00B8A:  BCLR.B  42.1
00B8C:  BCLR.B  42.0
00B8E:  RLC     W6,W6
00B90:  SWAP    W6
00B92:  AND     #FF,W6
00B94:  CP0     W6
00B96:  BRA     Z,CDA
00B98:  BCLR.B  42.1
00B9A:  BCLR.B  42.0
00B9C:  RLC     W7,W7
00B9E:  SWAP    W7
00BA0:  AND     #FF,W7
00BA2:  CP0     W7
00BA4:  BRA     Z,CE4
00BA6:  BCLR.B  42.1
00BA8:  BCLR.B  42.0
00BAA:  CP      W7,W6
00BAC:  BRA     Z,CE6
00BAE:  BRA     N,CF6
00BB0:  BCLR    W9.0
00BB2:  BSET    W9.1
00BB4:  SUB     W7,W6,W8
00BB6:  MOV     W7,W6
00BB8:  AND     #FF,W1
00BBA:  BSET    W1.7
00BBC:  AND     #FF,W3
00BBE:  BSET    W3.7
00BC0:  MOV     #28,W7
00BC2:  CP      W7,W8
00BC4:  BRA     N,BE8
00BC6:  BCLR.B  42.1
00BC8:  BCLR.B  42.0
00BCA:  RRC     W1,W1
00BCC:  RRC     W0,W0
00BCE:  DEC     W8,W8
00BD0:  BRA     NZ,BC6
00BD2:  BRA     BEE
00BD4:  MOV     #28,W7
00BD6:  CP      W7,W8
00BD8:  BRA     N,BEC
00BDA:  BCLR.B  42.1
00BDC:  BCLR.B  42.0
00BDE:  RRC     W3,W3
00BE0:  RRC     W2,W2
00BE2:  DEC     W8,W8
00BE4:  BRA     NZ,BDA
00BE6:  BRA     C06
00BE8:  MOV     W2,W0
00BEA:  MOV     W3,W1
00BEC:  BRA     C74
00BEE:  BTSS    W11.F
00BF0:  BRA     C14
00BF2:  BTSC    W9.4
00BF4:  MOV     W12,W11
00BF6:  NEG     W0,W0
00BF8:  BRA     Z,BFE
00BFA:  COM.B   W1L,W1L
00BFC:  BRA     C00
00BFE:  NEG     W1,W1
00C00:  BTSC    W9.4
00C02:  BRA     C5A
00C04:  BRA     C14
00C06:  BTSS    W11.F
00C08:  BRA     C14
00C0A:  NEG     W2,W2
00C0C:  BRA     Z,C12
00C0E:  COM.B   W3L,W3L
00C10:  BRA     C14
00C12:  NEG     W3,W3
00C14:  AND     #FF,W5
00C16:  BCLR.B  42.1
00C18:  BCLR.B  42.0
00C1A:  ADD     W0,W2,W0
00C1C:  ADDC.B  W1L,W3L,W1L
00C1E:  BTSC.B  42.0
00C20:  BSET    W9.3
00C22:  BTSC    W9.0
00C24:  BRA     C38
00C26:  BTSC    W9.1
00C28:  BRA     C2C
00C2A:  BRA     C42
00C2C:  BTSC    W11.F
00C2E:  BRA     C5A
00C30:  BTSC    W9.3
00C32:  BRA     C86
00C34:  BSET    W9.6
00C36:  BRA     C74
00C38:  BTSC    W11.F
00C3A:  BRA     C5A
00C3C:  BTSC    W9.3
00C3E:  BRA     C86
00C40:  BRA     C74
00C42:  BCLR    W9.2
00C44:  BTSC    W11.F
00C46:  BRA     C50
00C48:  MOV     W10,W11
00C4A:  BTSC    W9.3
00C4C:  BRA     C86
00C4E:  BRA     CBC
00C50:  BSET    W9.4
00C52:  XOR.B   #80,W1L
00C54:  BTSC    W1.7
00C56:  BRA     BF2
00C58:  MOV     W10,W11
00C5A:  AND     #FF,W1
00C5C:  IOR      W0,  W1,W7
00C5E:  BRA     Z,C74
00C60:  BTSC    W1.7
00C62:  BRA     C74
00C64:  BCLR.B  42.1
00C66:  BCLR.B  42.0
00C68:  RLC     W0,W0
00C6A:  RLC     W1,W1
00C6C:  DEC     W6,W6
00C6E:  BTSC.B  42.1
00C70:  BRA     CD4
00C72:  BRA     C60
00C74:  BTSC    W9.0
00C76:  MOV     W10,W11
00C78:  BTSC    W9.1
00C7A:  MOV     W12,W11
00C7C:  BTSS    W9.5
00C7E:  BRA     CB4
00C80:  BTSC    W10.F
00C82:  BSET    W0.8
00C84:  BRA     CBC
00C86:  BSET.B  42.0
00C88:  RRC.B   W1L,W1L
00C8A:  RRC     W0,W0
00C8C:  BTSC.B  42.0
00C8E:  BSET    W9.5
00C90:  INC     W6,W6
00C92:  BRA     Z,CD4
00C94:  BTSS    W9.5
00C96:  BRA     CA8
00C98:  INC     W0,W0
00C9A:  BRA     NZ,CA8
00C9C:  INC.B   W1L,W1L
00C9E:  BRA     NZ,CA8
00CA0:  RRC.B   W1L,W1L
00CA2:  RRC     W0,W0
00CA4:  INC     W6,W6
00CA6:  BRA     Z,CD4
00CA8:  BTSC    W9.0
00CAA:  MOV     W10,W11
00CAC:  BTSC    W9.1
00CAE:  MOV     W12,W11
00CB0:  BTSC.B  42.1
00CB2:  BRA     CD4
00CB4:  BTSC    W9.6
00CB6:  MOV     W10,W11
00CB8:  BTSC    W9.7
00CBA:  MOV     W12,W11
00CBC:  IOR      W0,  W1,W2
00CBE:  BRA     Z,D06
00CC0:  BCLR    W1.7
00CC2:  SWAP    W6
00CC4:  BCLR.B  42.1
00CC6:  BCLR.B  42.0
00CC8:  RRC     W6,W6
00CCA:  XOR     W6,W1,W1
00CCC:  BSET    W1.F
00CCE:  BTSS    W11.F
00CD0:  BCLR    W1.F
00CD2:  BRA     D06
00CD4:  MOV     #0,W0
00CD6:  MOV     #0,W1
00CD8:  BRA     D06
00CDA:  BTSC    W10.F
00CDC:  XOR     W8,W3,W3
00CDE:  MOV     W2,W0
00CE0:  MOV     W3,W1
00CE2:  BRA     D06
00CE4:  BRA     D06
00CE6:  AND     #FF,W3
00CE8:  BSET    W3.7
00CEA:  AND     #FF,W1
00CEC:  BSET    W1.7
00CEE:  BTSC    W11.F
00CF0:  BCLR    W3.7
00CF2:  BSET    W9.2
00CF4:  BRA     C06
00CF6:  SUB     W6,W7,W8
00CF8:  AND     #FF,W1
00CFA:  BSET    W1.7
00CFC:  AND     #FF,W3
00CFE:  BSET    W3.7
00D00:  BCLR    W9.1
00D02:  BSET    W9.0
00D04:  BRA     BD4
00D06:  MOV     #12,W5
00D08:  REPEAT  #3
00D0A:  MOV     [--W15],[W5--]
00D0C:  MOV     [--W15],W5
00D0E:  RETURN  
*
00F16:  MOV     W5,[W15++]
00F18:  MOV     W6,[W15++]
00F1A:  MOV     #8E,W1
00F1C:  BCLR    W6.0
00F1E:  BTSS    W0.F
00F20:  BRA     F28
00F22:  BSET    W6.0
00F24:  NEG     W0,W0
00F26:  BRA     F28
00F28:  CP0     W0
00F2A:  BRA     Z,F54
00F2C:  BTSC    W0.F
00F2E:  BRA     F38
00F30:  BCLR.B  42.0
00F32:  RLC     W0,W0
00F34:  DEC     W1,W1
00F36:  BRA     F2C
00F38:  SWAP    W1
00F3A:  BCLR.B  42.0
00F3C:  RRC     W1,W1
00F3E:  BCLR    W0.F
00F40:  SWAP    W0
00F42:  XOR.B   W0L,W1L,W1L
00F44:  AND.B   #0,W0L
00F46:  BTSC    W6.0
00F48:  BSET    W1.F
00F4A:  BRA     F5A
00F4C:  MOV.B   W1L,W0L
00F4E:  BSET    W1.7
00F50:  AND.B   #0,W1L
00F52:  BRA     F5A
00F54:  CLR     W0
00F56:  CLR     W1
00F58:  BRA     F5A
00F5A:  MOV     [--W15],W6
00F5C:  MOV     [--W15],W5
00F5E:  RETURN  
00F60:  MOV     W5,[W15++]
00F62:  MOV     #C,W5
00F64:  REPEAT  #4
00F66:  MOV     [W5++],[W15++]
00F68:  CLR     W9
00F6A:  XOR     W1,W3,W9
00F6C:  MOV     W1,W6
00F6E:  MOV     W0,W5
00F70:  MOV     W3,W8
00F72:  MOV     W2,W7
00F74:  RLC     W1,W1
00F76:  SWAP    W1
00F78:  ZE      W1,W1
00F7A:  CP0     W1
00F7C:  BRA     Z,101A
00F7E:  RLC     W3,W3
00F80:  SWAP    W3
00F82:  ZE      W3,W3
00F84:  CP0     W3
00F86:  BRA     Z,101A
00F88:  CLR     W0
00F8A:  SUB.B   W1L,W3L,W0L
00F8C:  BRA     NC,F94
00F8E:  ADD.B   #7F,W0L
00F90:  BRA     C,101A
00F92:  BRA     F9A
00F94:  SUB.B   #81,W0L
00F96:  BRA     NC,101A
00F98:  BRA     Z,101A
00F9A:  MOV     W5,W1
00F9C:  MOV     W6,W2
00F9E:  BSET    W2.7
00FA0:  AND     #FF,W2
00FA2:  AND     #FF,W8
00FA4:  BSET    W8.7
00FA6:  MOV     #19,W10
00FA8:  CLR     W3
00FAA:  CLR     W4
00FAC:  SUB     W1,W7,W1
00FAE:  SUBB    W2,W8,W2
00FB0:  BRA     N,FB6
00FB2:  BRA     C,FBC
00FB4:  BRA     NZ,FBE
00FB6:  ADD     W1,W7,W1
00FB8:  ADDC    W2,W8,W2
00FBA:  BRA     FBE
00FBC:  BSET    W4.0
00FBE:  DEC     W10,W10
00FC0:  BRA     Z,FD0
00FC2:  BCLR.B  42.0
00FC4:  RLC     W1,W1
00FC6:  RLC     W2,W2
00FC8:  BCLR.B  42.0
00FCA:  RLC     W4,W4
00FCC:  RLC     W3,W3
00FCE:  BRA     FAC
00FD0:  CLR     W10
00FD2:  BTSC    W3.8
00FD4:  BRA     FD8
00FD6:  BRA     FE4
00FD8:  BCLR.B  42.0
00FDA:  RRC     W3,W3
00FDC:  BCLR    W3.7
00FDE:  RRC     W4,W4
00FE0:  RLC     W10,W10
00FE2:  BRA     FE8
00FE4:  DEC     W0,W0
00FE6:  BRA     Z,101A
00FE8:  BTSC    W10.F
00FEA:  BRA     NC,FF6
00FEC:  RLC     W1,W1
00FEE:  RLC     W2,W2
00FF0:  SUB     W1,W7,W1
00FF2:  SUBB    W2,W8,W2
00FF4:  BRA     NC,1008
00FF6:  INC     W4,W4
00FF8:  BRA     NZ,1008
00FFA:  INC     W3,W3
00FFC:  BRA     NZ,1008
00FFE:  INC     W0,W0
01000:  BRA     Z,101A
01002:  BRA     1008
01004:  DEC     W0,W0
01006:  BRA     Z,101A
01008:  SWAP    W0
0100A:  RRC     W0,W1
0100C:  BSET    W1.F
0100E:  BTSS    W9.F
01010:  BCLR    W1.F
01012:  BCLR    W3.7
01014:  XOR.B   W3L,W1L,W1L
01016:  MOV     W4,W0
01018:  BRA     1020
0101A:  MOV     #0,W0
0101C:  MOV     #0,W1
0101E:  BRA     1020
01020:  MOV     #14,W5
01022:  REPEAT  #4
01024:  MOV     [--W15],[W5--]
01026:  MOV     [--W15],W5
01028:  RETURN  
*
01430:  MOV     W8,[W15++]
01432:  MOV     #12,W8
01434:  REPEAT  #4
01436:  MOV     [W8++],[W15++]
01438:  MOV     #8000,W8
0143A:  BTSC.B  43.0
0143C:  XOR     W8,W7,W7
0143E:  CP0     W0
01440:  BRA     NZ,1450
01442:  CP0     W1
01444:  BRA     NZ,1450
01446:  CP0     W2
01448:  BRA     NZ,1450
0144A:  MOV     #7FFF,W10
0144C:  AND     W3,W10,W10
0144E:  BTSS.B  42.1
01450:  MOV     W3,W10
01452:  XOR     W7,W10,W11
01454:  MOV     W3,W8
01456:  MOV     W7,W9
01458:  MOV     W7,W12
0145A:  MOV     #7FF,W13
0145C:  BCLR.B  42.1
0145E:  BCLR.B  42.0
01460:  ASR     W8,#4,W8
01462:  AND     W13,W8,W8
01464:  CP0     W8
01466:  BRA     Z,15E0
01468:  BCLR.B  42.1
0146A:  BCLR.B  42.0
0146C:  ASR     W9,#4,W9
0146E:  AND     W13,W9,W9
01470:  CP0     W9
01472:  BRA     Z,15F0
01474:  CLR     W13
01476:  BCLR.B  42.1
01478:  BCLR.B  42.0
0147A:  CP      W9,W8
0147C:  BRA     Z,15F2
0147E:  BRA     N,1602
01480:  BCLR    W13.0
01482:  BSET    W13.1
01484:  SUB     W9,W8,W8
01486:  AND     #F,W3
01488:  BSET    W3.4
0148A:  AND     #F,W7
0148C:  BSET    W7.4
0148E:  SUB     #34,W8
01490:  BRA     NN,14BE
01492:  ADD     #34,W8
01494:  BCLR.B  42.1
01496:  BCLR.B  42.0
01498:  RRC     W3,W3
0149A:  RRC     W2,W2
0149C:  RRC     W1,W1
0149E:  RRC     W0,W0
014A0:  DEC     W8,W8
014A2:  BRA     NZ,1494
014A4:  BRA     14CE
014A6:  SUB     #34,W8
014A8:  BRA     NN,14C8
014AA:  ADD     #34,W8
014AC:  BCLR.B  42.1
014AE:  BCLR.B  42.0
014B0:  RRC     W7,W7
014B2:  RRC     W6,W6
014B4:  RRC     W5,W5
014B6:  RRC     W4,W4
014B8:  DEC     W8,W8
014BA:  BRA     NZ,14AC
014BC:  BRA     14F4
014BE:  MOV     W4,W0
014C0:  MOV     W5,W1
014C2:  MOV     W6,W2
014C4:  MOV     W7,W3
014C6:  XOR     W11,W12,W12
014C8:  BTSC    W12.F
014CA:  BTG     W11.F
014CC:  BRA     15C0
014CE:  BTSS    W11.F
014D0:  BRA     1510
014D2:  BTSC    W13.4
014D4:  MOV     W12,W11
014D6:  COM     W0,W0
014D8:  COM     W1,W1
014DA:  COM     W2,W2
014DC:  COM.B   W3L,W3L
014DE:  AND.B   #1F,W3L
014E0:  INC     W0,W0
014E2:  BRA     NZ,14EE
014E4:  INC     W1,W1
014E6:  BRA     NZ,14EE
014E8:  INC     W2,W2
014EA:  BRA     NZ,14EE
014EC:  INC.B   W3L,W3L
014EE:  BTSC    W13.4
014F0:  BRA     1556
014F2:  BRA     1510
014F4:  BTSS    W11.F
014F6:  BRA     1510
014F8:  COM     W4,W4
014FA:  COM     W5,W5
014FC:  COM     W6,W6
014FE:  COM.B   W7L,W7L
01500:  AND.B   #1F,W7L
01502:  INC     W4,W4
01504:  BRA     NZ,1510
01506:  INC     W5,W5
01508:  BRA     NZ,1510
0150A:  INC     W6,W6
0150C:  BRA     NZ,1510
0150E:  INC.B   W7L,W7L
01510:  BCLR.B  42.1
01512:  BCLR.B  42.0
01514:  ADD     W0,W4,W0
01516:  ADDC    W1,W5,W1
01518:  ADDC    W2,W6,W2
0151A:  ADDC.B  W3L,W7L,W3L
0151C:  BTSC    W3.5
0151E:  BSET    W13.3
01520:  BTSC    W13.0
01522:  BRA     1536
01524:  BTSC    W13.1
01526:  BRA     152A
01528:  BRA     1540
0152A:  BTSC    W11.F
0152C:  BRA     1556
0152E:  BTSC    W13.3
01530:  BRA     1584
01532:  BSET    W13.6
01534:  BRA     1578
01536:  BTSC    W11.F
01538:  BRA     1556
0153A:  BTSC    W13.3
0153C:  BRA     1584
0153E:  BRA     1578
01540:  BTSC    W11.F
01542:  BRA     154C
01544:  MOV     W10,W11
01546:  BTSC    W13.3
01548:  BRA     1584
0154A:  BRA     15C0
0154C:  BSET    W13.4
0154E:  XOR.B   #10,W3L
01550:  BTSC    W3.4
01552:  BRA     14D2
01554:  MOV     W10,W11
01556:  AND     #1F,W3
01558:  IOR      W3,  W2,W8
0155A:  BRA     NZ,1560
0155C:  IOR      W1,  W0,W8
0155E:  BRA     Z,1578
01560:  BTSC    W3.4
01562:  BRA     1578
01564:  BCLR.B  42.1
01566:  BCLR.B  42.0
01568:  RLC     W0,W0
0156A:  RLC     W1,W1
0156C:  RLC     W2,W2
0156E:  RLC     W3,W3
01570:  DEC     W9,W9
01572:  BTSC.B  42.1
01574:  BRA     15DA
01576:  BRA     1560
01578:  BTSC    W13.0
0157A:  MOV     W10,W11
0157C:  BTSC    W13.1
0157E:  MOV     W12,W11
01580:  BTSS    W13.5
01582:  BRA     15C0
01584:  BCLR.B  42.0
01586:  RRC.B   W3L,W3L
01588:  RRC     W2,W2
0158A:  RRC     W1,W1
0158C:  RRC     W0,W0
0158E:  BTSC.B  42.0
01590:  BSET    W13.5
01592:  INC     W9,W9
01594:  BTSC.B  42.1
01596:  BRA     15DA
01598:  BTSS    W13.5
0159A:  BRA     15B8
0159C:  INC     W0,W0
0159E:  BRA     NZ,15B8
015A0:  INC     W1,W1
015A2:  BRA     NZ,15B8
015A4:  INC     W2,W2
015A6:  BRA     NZ,15B8
015A8:  INC     W3,W3
015AA:  BRA     NZ,15B8
015AC:  RRC.B   W3L,W3L
015AE:  RRC     W2,W2
015B0:  RRC     W1,W1
015B2:  RRC     W0,W0
015B4:  INC     W9,W9
015B6:  BRA     Z,15DA
015B8:  BTSC    W13.0
015BA:  MOV     W10,W11
015BC:  BTSC    W13.1
015BE:  MOV     W12,W11
015C0:  IOR      W0,  W1,W4
015C2:  BRA     NZ,15C8
015C4:  IOR      W2,  W3,W4
015C6:  BRA     Z,1614
015C8:  BCLR    W3.4
015CA:  BCLR.B  42.1
015CC:  BCLR.B  42.0
015CE:  SL      W9,#4,W9
015D0:  XOR     W9,W3,W3
015D2:  BSET    W3.F
015D4:  BTSS    W11.F
015D6:  BCLR    W3.F
015D8:  BRA     1614
015DA:  MUL.UU  W0,#0,W0
015DC:  MUL.UU  W2,#0,W2
015DE:  BRA     1614
015E0:  MOV     #8000,W8
015E2:  BTSC    W10.F
015E4:  XOR     W8,W7,W7
015E6:  MOV     W5,W1
015E8:  MOV     W4,W0
015EA:  MOV     W6,W2
015EC:  MOV     W7,W3
015EE:  BRA     1614
015F0:  BRA     1614
015F2:  AND     #F,W7
015F4:  BSET    W7.4
015F6:  AND     #F,W3
015F8:  BSET    W3.4
015FA:  BTSC    W11.F
015FC:  BCLR    W7.4
015FE:  BSET    W13.2
01600:  BRA     14F4
01602:  AND     #F,W3
01604:  BSET    W3.4
01606:  AND     #F,W7
01608:  BSET    W7.4
0160A:  SUB     W8,W9,W8
0160C:  ADD     W8,W9,W9
0160E:  BCLR    W13.1
01610:  BSET    W13.0
01612:  BRA     14A6
01614:  MOV     #1A,W8
01616:  REPEAT  #4
01618:  MOV     [--W15],[W8--]
0161A:  MOV     [--W15],W8
0161C:  RETURN  
*
01B0E:  MOV     W5,[W15++]
01B10:  MOV     W2,W3
01B12:  MOV     W2,W5
01B14:  BCLR.B  42.0
01B16:  RLC     W3,W3
01B18:  SWAP    W3
01B1A:  AND     #FF,W3
01B1C:  BRA     NZ,1B24
01B1E:  MUL.UU  W0,#0,W0
01B20:  MUL.UU  W2,#0,W2
01B22:  BRA     1B50
01B24:  ADD     #380,W3
01B26:  AND     #7F,W2
01B28:  MOV     #3,W6
01B2A:  CLR     W4
01B2C:  BCLR.B  42.0
01B2E:  RRC     W2,W2
01B30:  RRC     W1,W1
01B32:  RRC     W0,W0
01B34:  BTSC.B  42.0
01B36:  INC     W4,W4
01B38:  DEC     W6,W6
01B3A:  BRA     NZ,1B2C
01B3C:  BCLR    W2.7
01B3E:  SL      W3,#4,W3
01B40:  BCLR    W3.F
01B42:  BTSC    W5.F
01B44:  BSET    W3.F
01B46:  XOR     W2,W3,W3
01B48:  MOV     W1,W2
01B4A:  MOV     W0,W1
01B4C:  ADD     W4,W1,W1
01B4E:  CLR     W0
01B50:  MOV     [--W15],W5
01B52:  RETURN  
01B54:  MOV     W5,[W15++]
01B56:  MOV     #C,W5
01B58:  REPEAT  #5
01B5A:  MOV     [W5++],[W15++]
01B5C:  MOV     W3,W8
01B5E:  MOV     W2,W7
01B60:  MOV     W1,W6
01B62:  MOV     W0,W5
01B64:  MOV     W3,W9
01B66:  MOV     #473,W11
01B68:  ASR     W3,#4,W3
01B6A:  MOV     #7FF,W10
01B6C:  AND     W10,W3,W3
01B6E:  SUB     W11,W3,W11
01B70:  AND     #1F,W8
01B72:  BSET    W8.4
01B74:  CLR     W0
01B76:  CLR     W1
01B78:  CLR     W2
01B7A:  CLR     W3
01B7C:  BCLR.B  42.0
01B7E:  RRC     W8,W8
01B80:  RRC     W7,W7
01B82:  RRC     W6,W6
01B84:  RRC     W5,W5
01B86:  RRC     W3,W3
01B88:  RRC     W2,W2
01B8A:  RRC     W1,W1
01B8C:  RRC     W0,W0
01B8E:  DEC     W11,W11
01B90:  BRA     NZ,1B7C
01B92:  BTSS    W9.F
01B94:  BRA     1BA0
01B96:  NEG     W0,W0
01B98:  COM     W1,W1
01B9A:  COM     W2,W2
01B9C:  COM     W3,W3
01B9E:  BRA     1BA0
01BA0:  MOV     #16,W5
01BA2:  REPEAT  #5
01BA4:  MOV     [--W15],[W5--]
01BA6:  MOV     [--W15],W5
01BA8:  RETURN  
01BAA:  MOV     W12,[W15++]
01BAC:  MOV     W13,[W15++]
01BAE:  CLR     W8
01BB0:  CLR     W9
01BB2:  CLR     W10
01BB4:  CLR     W11
01BB6:  CLR     W12
01BB8:  CLR     W13
01BBA:  MOV     #E,W8
01BBC:  MOV     #0,W9
01BBE:  LNK     #10
01BC0:  MOV     W12,[W14+W8]
01BC2:  DEC2    W8,W8
01BC4:  BRA     NN,1BC0
01BC6:  XOR     W4,W5,W8
01BC8:  BRA     NZ,1BCE
01BCA:  XOR     W6,W7,W8
01BCC:  BRA     Z,1C2C
01BCE:  CLR     W8
01BD0:  MOV     #40,W13
01BD2:  MOV     #40,W13
01BD4:  BCLR.B  42.0
01BD6:  RLC     W0,W0
01BD8:  RLC     W1,W1
01BDA:  RLC     W2,W2
01BDC:  RLC     W3,W3
01BDE:  RLC     W8,W8
01BE0:  RLC     W9,W9
01BE2:  RLC     W10,W10
01BE4:  RLC     W11,W11
01BE6:  CP      W11,W7
01BE8:  BRA     NZ,1BF4
01BEA:  CPB     W10,W6
01BEC:  BRA     NZ,1BF4
01BEE:  CPB     W9,W5
01BF0:  BRA     NZ,1BF4
01BF2:  CPB     W8,W4
01BF4:  BRA     NC,1C00
01BF6:  SUB     W8,W4,W8
01BF8:  SUBB    W9,W5,W9
01BFA:  SUBB    W10,W6,W10
01BFC:  SUBB    W11,W7,W11
01BFE:  BSET.B  42.0
01C00:  MOV     W8,[W14]
01C02:  MOV     W9,[W14+#2]
01C04:  MOV     W10,[W14+#4]
01C06:  MOV     W11,[W14+#6]
01C08:  MOV     [W14+#8],W8
01C0A:  MOV     [W14+#A],W9
01C0C:  MOV     [W14+#C],W10
01C0E:  MOV     [W14+#E],W11
01C10:  RLC     W8,W8
01C12:  RLC     W9,W9
01C14:  RLC     W10,W10
01C16:  RLC     W11,W11
01C18:  MOV     W8,[W14+#8]
01C1A:  MOV     W9,[W14+#A]
01C1C:  MOV     W10,[W14+#C]
01C1E:  MOV     W11,[W14+#E]
01C20:  MOV     [W14],W8
01C22:  MOV     [W14+#2],W9
01C24:  MOV     [W14+#4],W10
01C26:  MOV     [W14+#6],W11
01C28:  DEC     W13,W13
01C2A:  BRA     NZ,1BD4
01C2C:  MOV     [W14+#8],W0
01C2E:  MOV     [W14+#A],W1
01C30:  MOV     [W14+#C],W2
01C32:  MOV     [W14+#E],W3
01C34:  ULNK    
01C36:  BRA     1C38
01C38:  MOV     [--W15],W13
01C3A:  MOV     [--W15],W12
01C3C:  RETURN  
01C3E:  MOV     W5,[W15++]
01C40:  MOV     #C,W5
01C42:  REPEAT  #7
01C44:  MOV     [W5++],[W15++]
01C46:  LNK     #2A
01C48:  MOV     #28,W8
01C4A:  CLR     W12
01C4C:  MOV     W12,[W14+W8]
01C4E:  DEC2    W8,W8
01C50:  BRA     NN,1C4C
01C52:  MOV     W10,[W14+#28]
01C54:  CP0     W9
01C56:  BRA     Z,1C72
01C58:  MOV     W9,[W14+#26]
01C5A:  MOV     #4024,W7
01C5C:  CLR     W6
01C5E:  MUL.UU  W4,#0,W4
01C60:  MOV     W9,[W14+#24]
01C62:  MOV     #4024,W7
01C64:  CLR     W6
01C66:  MUL.UU  W4,#0,W4
01C68:  CALL    778
01C6C:  MOV     [W14+#24],W9
01C6E:  DEC     W9,W9
01C70:  BRA     NZ,1C60
01C72:  MOV     [W14+#26],W9
01C74:  MOV     #14,W8
01C76:  MOV     W8,[W14+#24]
01C78:  MOV     #41CD,W7
01C7A:  MOV     #CD65,W6
01C7C:  MUL.UU  W4,#0,W4
01C7E:  MOV     W0,[W14+#10]
01C80:  MOV     W1,[W14+#12]
01C82:  MOV     W2,[W14+#14]
01C84:  MOV     W3,[W14+#16]
01C86:  MOV     #14,W8
01C88:  MOV     W8,[W14+#20]
01C8A:  MOV     #0,W4
01C8C:  MOV     #89E8,W5
01C8E:  MOV     #2304,W6
01C90:  MOV     #8AC7,W7
01C92:  MOV     W4,[W14+#18]
01C94:  MOV     W5,[W14+#1A]
01C96:  MOV     W6,[W14+#1C]
01C98:  MOV     W7,[W14+#1E]
01C9A:  BTSS    W3.F
01C9C:  BRA     1CA6
01C9E:  MOV     [W14+#28],W8
01CA0:  DEC     W8,W8
01CA2:  BSET    W8.D
01CA4:  MOV     W8,[W14+#28]
01CA6:  BCLR    W3.F
01CA8:  CALL    1B54
01CAC:  MOV     [W14+#28],W8
01CAE:  MOV     [W14+#26],W9
01CB0:  CP0     W9
01CB2:  BTSC.B  42.1
01CB4:  INC.B   W8L,W8L
01CB6:  MOV     W8,[W14+#28]
01CB8:  MOV     [W14+#22],W9
01CBA:  CLR     W9
01CBC:  MOV     W9,[W14+#22]
01CBE:  MOV     [W14+#18],W4
01CC0:  MOV     [W14+#1A],W5
01CC2:  MOV     [W14+#1C],W6
01CC4:  MOV     [W14+#1E],W7
01CC6:  CALL    1BAA
01CCA:  MOV     [W14+#22],W13
01CCC:  BTSC    W13.0
01CCE:  BRA     1DA0
01CD0:  MOV     W8,[W14+#10]
01CD2:  MOV     W9,[W14+#12]
01CD4:  MOV     W10,[W14+#14]
01CD6:  MOV     W11,[W14+#16]
01CD8:  MOV     [W14+#22],W13
01CDA:  BTG     W13.0
01CDC:  MOV     W13,[W14+#22]
01CDE:  CP0     W0
01CE0:  BRA     NZ,1D06
01CE2:  MOV     [W14+#26],W9
01CE4:  INC     W9,W9
01CE6:  MOV     [W14+#24],W10
01CE8:  SUB     W10,W9,W8
01CEA:  BRA     Z,1D06
01CEC:  MOV     [W14+#28],W11
01CEE:  CP0     W11
01CF0:  BRA     Z,1D0E
01CF2:  AND     W11,#1F,W8
01CF4:  SUB     W10,W8,W8
01CF6:  BRA     Z,1CFA
01CF8:  BRA     C,1D88
01CFA:  BTSC    W11.F
01CFC:  BRA     1D88
01CFE:  BTSC    W11.E
01D00:  BRA     1D0E
01D02:  MOV     #20,W0
01D04:  BRA     1D7A
01D06:  MOV     [W14+#28],W11
01D08:  MOV     #2000,W12
01D0A:  AND     W12,W11,W11
01D0C:  MOV     W11,[W14+#28]
01D0E:  MOV     [W14+#28],W11
01D10:  BTSS    W11.D
01D12:  BRA     1D34
01D14:  BCLR    W11.D
01D16:  MOV     [W14+#26],W9
01D18:  CP0     W9
01D1A:  BTSS.B  42.1
01D1C:  DEC     W11,W11
01D1E:  CLR     W11
01D20:  MOV     W11,[W14+#28]
01D22:  MOV     W0,W10
01D24:  MOV     W1,[W15++]
01D26:  MOV.B   #2D,W0L
01D28:  CALL    4F2
01D2C:  MOV     [--W15],W1
01D2E:  MOV     W10,W0
01D30:  CLR     W11
01D32:  MOV     W11,[W14+#28]
01D34:  MOV     [W14+#26],W9
01D36:  MOV     [W14+#24],W10
01D38:  SUB     W10,W9,W8
01D3A:  BRA     NZ,1D56
01D3C:  CLR     W11
01D3E:  MOV     W11,[W14+#28]
01D40:  MOV     W0,W10
01D42:  MOV     W1,[W15++]
01D44:  MOV.B   #2E,W0L
01D46:  CALL    4F2
01D4A:  MOV     [--W15],W1
01D4C:  MOV     [W14+#28],W11
01D4E:  MOV     #2000,W12
01D50:  AND     W12,W11,W11
01D52:  MOV     W11,[W14+#28]
01D54:  MOV     W10,W0
01D56:  MOV     #30,W1
01D58:  MOV     [W14+#28],W11
01D5A:  BTSS    W11.D
01D5C:  BRA     1D7A
01D5E:  BCLR    W11.D
01D60:  MOV     [W14+#26],W9
01D62:  CP0     W9
01D64:  BTSS.B  42.1
01D66:  DEC     W11,W11
01D68:  CLR     W11
01D6A:  MOV     W11,[W14+#28]
01D6C:  MOV     W1,[W15++]
01D6E:  MOV.B   #2D,W0L
01D70:  CALL    4F2
01D74:  MOV     [--W15],W1
01D76:  CLR     W0
01D78:  MOV     #30,W1
01D7A:  ADD     W1,W0,W0
01D7C:  MOV     W1,[W15++]
01D7E:  MOV     W0,[W15++]
01D80:  MOV     [--W15],W0
01D82:  CALL    4F2
01D86:  MOV     [--W15],W1
01D88:  MOV     [W14+#24],W13
01D8A:  DEC     W13,W13
01D8C:  BRA     Z,1DC0
01D8E:  MOV     W13,[W14+#24]
01D90:  MOV     [W14+#18],W0
01D92:  MOV     [W14+#1A],W1
01D94:  MOV     [W14+#1C],W2
01D96:  MOV     [W14+#1E],W3
01D98:  MOV     #A,W4
01D9A:  CLR     W5
01D9C:  MUL.UU  W6,#0,W6
01D9E:  BRA     1CC6
01DA0:  MOV     W0,[W14+#18]
01DA2:  MOV     W1,[W14+#1A]
01DA4:  MOV     W2,[W14+#1C]
01DA6:  MOV     W3,[W14+#1E]
01DA8:  MOV     W0,W4
01DAA:  MOV     W1,W5
01DAC:  MOV     W2,W6
01DAE:  MOV     W3,W7
01DB0:  MOV     [W14+#10],W0
01DB2:  MOV     [W14+#12],W1
01DB4:  MOV     [W14+#14],W2
01DB6:  MOV     [W14+#16],W3
01DB8:  MOV     [W14+#22],W13
01DBA:  BTG     W13.0
01DBC:  MOV     W13,[W14+#22]
01DBE:  BRA     1CC6
01DC0:  ULNK    
01DC2:  MOV     #1A,W5
01DC4:  REPEAT  #7
01DC6:  MOV     [--W15],[W5--]
01DC8:  MOV     [--W15],W5
01DCA:  RETURN  
....................  
.................... #list 
....................  
.................... #device ADC=12 
.................... #device ICSP=1 
.................... #use delay(crystal=8000000) 
*
00378:  CP0     W0
0037A:  BTSC.B  42.1
0037C:  BRA     386
0037E:  REPEAT  #7CB
00380:  NOP     
00382:  DEC     W0,W0
00384:  BRA     NZ,37E
00386:  RETURN  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES NOBROWNOUT               //No brownout reset 
....................  
....................  
.................... #use STANDARD_IO( F ) 
.................... #use rs232(UART1, baud=9600, stream=UART_PORT1) 
.................... #use rs232(UART2, baud=9600, stream=UART_PORT2) 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
*
00500:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
00502:  PUSH    C08
00504:  POP     C0A
00506:  MOV     C0A,W0
00508:  CP0.B   [W0]
0050A:  BRA     Z,512
0050C:  INC     0C0A
0050E:  GOTO    506
....................    return(sc - s); 
00512:  MOV     C0A,W4
00514:  MOV     C08,W3
00516:  SUB     W4,W3,W0
00518:  MOV     [--W15],W5
0051A:  RETURN  
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <Math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
*
00D10:  MOV     W5,[W15++]
00D12:  MOV     W6,[W15++]
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
00D14:  BCLR.B  A6F.0
....................    y = x; 
00D16:  PUSH    A6A
00D18:  POP     A70
00D1A:  PUSH    A6C
00D1C:  POP     A72
....................  
....................    if (x < 0) 
00D1E:  MOV     A6A,W0
00D20:  MOV     A6C,W1
00D22:  MOV     #0,W2
00D24:  MOV     #0,W3
00D26:  CALL    9D4
00D2A:  BRA     NC,D38
....................    { 
....................       s = 1; 
00D2C:  BSET.B  A6F.0
....................       y = -y; 
00D2E:  MOV     #A70,W0
00D30:  MOV     #A70,W1
00D32:  REPEAT  #3
00D34:  MOV     [W0++],[W1++]
00D36:  BTG.B   A73.7
....................    } 
....................  
....................    if (y <= 32768.0) 
00D38:  MOV     A70,W0
00D3A:  MOV     A72,W1
00D3C:  MOV     #0,W2
00D3E:  MOV     #4700,W3
00D40:  CALL    9D4
00D44:  BRA     C,D48
00D46:  BRA     NZ,D5C
....................       res = (float32)(unsigned int16)y; 
00D48:  MOV     A70,W0
00D4A:  MOV     A72,W1
00D4C:  CALL    A3C
00D50:  CALL    A68
00D54:  MOV     W0,A74
00D56:  MOV     W1,A76
00D58:  GOTO    DF0
....................  
....................  else if (y < 10000000.0) 
00D5C:  MOV     A70,W0
00D5E:  MOV     A72,W1
00D60:  MOV     #9680,W2
00D62:  MOV     #4B18,W3
00D64:  CALL    9D4
00D68:  BRA     NC,DE8
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
00D6A:  MOV     A70,W0
00D6C:  MOV     A72,W1
00D6E:  MOV     #0,W2
00D70:  MOV     #3800,W3
00D72:  CALL    AA2
00D76:  CALL    A3C
00D7A:  MOV     W0,A78
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
00D7C:  MOV     A70,W0
00D7E:  MOV     A72,W1
00D80:  MOV     #0,W2
00D82:  MOV     #3800,W3
00D84:  CALL    AA2
00D88:  MOV     W0,W5
00D8A:  MOV     W1,W6
00D8C:  MOV     A78,W0
00D8E:  CALL    A68
00D92:  BSET.B  43.0
00D94:  MOV     W0,W2
00D96:  MOV     W1,W3
00D98:  MOV     W5,W0
00D9A:  MOV     W6,W1
00D9C:  CALL    B66
00DA0:  MOV     W0,W2
00DA2:  MOV     W1,W3
00DA4:  MOV     #0,W0
00DA6:  MOV     #4700,W1
00DA8:  CALL    AA2
00DAC:  MOV     W0,A70
00DAE:  MOV     W1,A72
....................       res = 32768.0*(float32)l; 
00DB0:  MOV     A78,W0
00DB2:  CALL    A68
00DB6:  MOV     W0,W2
00DB8:  MOV     W1,W3
00DBA:  MOV     #0,W0
00DBC:  MOV     #4700,W1
00DBE:  CALL    AA2
00DC2:  MOV     W0,A74
00DC4:  MOV     W1,A76
....................       res += (float32)(unsigned int16)y; 
00DC6:  MOV     A70,W0
00DC8:  MOV     A72,W1
00DCA:  CALL    A3C
00DCE:  CALL    A68
00DD2:  BCLR.B  43.0
00DD4:  MOV     W0,W2
00DD6:  MOV     W1,W3
00DD8:  MOV     A74,W0
00DDA:  MOV     A76,W1
00DDC:  CALL    B66
00DE0:  MOV     W0,A74
00DE2:  MOV     W1,A76
....................    } 
00DE4:  GOTO    DF0
....................  
....................  else 
....................   res = y; 
00DE8:  PUSH    A70
00DEA:  POP     A74
00DEC:  PUSH    A72
00DEE:  POP     A76
....................  
....................  y = y - (float32)(unsigned int16)y; 
00DF0:  MOV     A70,W0
00DF2:  MOV     A72,W1
00DF4:  CALL    A3C
00DF8:  CALL    A68
00DFC:  BSET.B  43.0
00DFE:  MOV     W0,W2
00E00:  MOV     W1,W3
00E02:  MOV     A70,W0
00E04:  MOV     A72,W1
00E06:  CALL    B66
00E0A:  MOV     W0,A70
00E0C:  MOV     W1,A72
....................  
....................  if (s) 
00E0E:  BTSS.B  A6F.0
00E10:  BRA     E1C
....................   res = -res; 
00E12:  MOV     #A74,W0
00E14:  MOV     #A74,W1
00E16:  REPEAT  #3
00E18:  MOV     [W0++],[W1++]
00E1A:  BTG.B   A77.7
....................  
....................  if (y != 0) 
00E1C:  MOV     A70,W0
00E1E:  MOV     A72,W1
00E20:  MOV     #0,W2
00E22:  MOV     #0,W3
00E24:  CALL    9D4
00E28:  BRA     Z,E60
....................  { 
....................   if (s == 1 && n == 0) 
00E2A:  BTSS.B  A6F.0
00E2C:  BRA     E44
00E2E:  CP0.B   A6E
00E30:  BRA     NZ,E44
....................    res -= 1.0; 
00E32:  BSET.B  43.0
00E34:  MOV     A74,W0
00E36:  MOV     A76,W1
00E38:  MOV     #0,W2
00E3A:  MOV     #3F80,W3
00E3C:  CALL    B66
00E40:  MOV     W0,A74
00E42:  MOV     W1,A76
....................  
....................   if (s == 0 && n == 1) 
00E44:  BTSC.B  A6F.0
00E46:  BRA     E60
00E48:  MOV     A6E,W4
00E4A:  CP.B    W4L,#1
00E4C:  BRA     NZ,E60
....................    res += 1.0; 
00E4E:  BCLR.B  43.0
00E50:  MOV     A74,W0
00E52:  MOV     A76,W1
00E54:  MOV     #0,W2
00E56:  MOV     #3F80,W3
00E58:  CALL    B66
00E5C:  MOV     W0,A74
00E5E:  MOV     W1,A76
....................  } 
....................  if (x == 0) 
00E60:  MOV     A6A,W0
00E62:  MOV     A6C,W1
00E64:  MOV     #0,W2
00E66:  MOV     #0,W3
00E68:  CALL    9D4
00E6C:  BRA     NZ,E72
....................     res = 0; 
00E6E:  CLR     A74
00E70:  CLR     A76
....................  
....................  return (res); 
00E72:  MOV     A74,W0
00E74:  MOV     A76,W1
00E76:  MOV     [--W15],W6
00E78:  MOV     [--W15],W5
00E7A:  RETURN  
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
00E7C:  CLR.B   A6E
00E7E:  PUSH    A5C
00E80:  POP     A6A
00E82:  PUSH    A5E
00E84:  POP     A6C
00E86:  CALL    D10
00E8A:  MOV.D   W0,W0
00E8C:  RETURN  
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "Analog.c" 
.................... #define ADC000  0 
.................... #define ADC12V  2605.0 
....................  
.................... //--------khai bao bien UV ------------------// 
.................... float read_avg_UV (); 
.................... float read_single_UV (); 
....................  
.................... //--------khoi tao analog-------------------// 
.................... void ana_init() { 
....................    setup_adc_ports(sAN2 | sAN3, VSS_VDD); 
*
0036A:  MOV     #FFF3,W4
0036C:  MOV     W4,2A8
0036E:  CLR     2A2
....................    setup_adc(ADC_CLOCK | ADC_TAD_MUL_0); 
00370:  CLR     2A4
00372:  MOV     #80E0,W4
00374:  MOV     W4,2A0
00376:  RETURN  
.................... } 
....................  
.................... //--------doc analog-----------------------// 
.................... int16  read_analog() { 
*
00E8E:  MOV     W5,[W15++]
00E90:  MOV     W6,[W15++]
00E92:  MOV     W7,[W15++]
00E94:  MOV     W8,[W15++]
....................    int16 value; 
....................    float tmp; 
....................    set_adc_channel(2); 
00E96:  MOV     #2,W4
00E98:  MOV     W4,2A6
....................    delay_us(10); 
00E9A:  REPEAT  #12
00E9C:  NOP     
....................    value = read_adc(); 
00E9E:  BCLR.B  2A0.0
00EA0:  BSET.B  2A0.1
00EA2:  BTSS.B  2A0.0
00EA4:  BRA     EA2
00EA6:  PUSH    280
00EA8:  POP     A56
....................    tmp = (value * 1200.0) / ADC12V; 
00EAA:  MOV     A56,W0
00EAC:  CLR     W3
00EAE:  BTSC    W0.F
00EB0:  SETM    W3
00EB2:  MOV     W3,W1
00EB4:  MOV     W3,W2
00EB6:  CALL    714
00EBA:  MOV     #0,W4
00EBC:  MOV     #0,W5
00EBE:  MOV     #C000,W6
00EC0:  MOV     #4092,W7
00EC2:  CALL    778
00EC6:  MOV     W0,W5
00EC8:  MOV     W1,W6
00ECA:  MOV     W2,W7
00ECC:  MOV     W3,W8
00ECE:  MOV     W5,[W15++]
00ED0:  MOV     W6,[W15++]
00ED2:  MOV     W7,[W15++]
00ED4:  MOV     W5,W0
00ED6:  MOV     W6,W1
00ED8:  MOV     W7,W2
00EDA:  MOV     W8,W3
00EDC:  MOV     #0,W4
00EDE:  MOV     #0,W5
00EE0:  MOV     #5A00,W6
00EE2:  MOV     #40A4,W7
00EE4:  CALL    888
00EE8:  MOV     [--W15],W7
00EEA:  MOV     [--W15],W6
00EEC:  MOV     [--W15],W5
00EEE:  CALL    990
00EF2:  MOV     W1,A58
00EF4:  MOV     W2,A5A
....................    value = (int16) floor (tmp);    
00EF6:  PUSH    A58
00EF8:  POP     A5C
00EFA:  PUSH    A5A
00EFC:  POP     A5E
00EFE:  CALL    E7C
00F02:  CALL    A3C
00F06:  MOV     W0,A56
....................  
....................    return value;   
00F08:  PUSH    A56
00F0A:  POP     0
00F0C:  MOV     [--W15],W8
00F0E:  MOV     [--W15],W7
00F10:  MOV     [--W15],W6
00F12:  MOV     [--W15],W5
00F14:  RETURN  
.................... } 
....................  
.................... float read_avg_UV () 
*
010D2:  MOV     W5,[W15++]
010D4:  MOV     W6,[W15++]
.................... { 
....................    float uv_buff[10]; 
....................    float temp; 
....................    float avgValue; 
....................     
....................       // read 10 sample 
....................      for (int k = 0; k < 10; k++){ 
010D6:  CLR     A40
010D8:  MOV     A40,W4
010DA:  CP      W4,#A
010DC:  BRA     GE,10F6
....................          uv_buff[k] = read_single_UV(); 
010DE:  MOV     A40,W4
010E0:  MUL.UU  W4,#4,W0
010E2:  MOV     #A10,W4
010E4:  ADD     W0,W4,W5
010E6:  CALL    102A
010EA:  MOV     #0,W4
010EC:  MOV     [W4++],[W5++]
010EE:  MOV     [W4++],[W5++]
010F0:  INC     0A40
010F2:  GOTO    10D8
....................       } 
....................       // sort 10 sample 
....................       for (int i = 0; i < 9; i++){ 
010F6:  CLR     A42
010F8:  MOV     A42,W4
010FA:  CP      W4,#9
010FC:  BRA     GE,116E
....................          for (int j = i + 1; j < 10; j++){ 
010FE:  MOV     A42,W4
01100:  ADD     W4,#1,W4
01102:  MOV     W4,A44
01104:  MOV     A44,W4
01106:  CP      W4,#A
01108:  BRA     GE,1168
....................             if (uv_buff[i] > uv_buff[j]){ 
0110A:  MOV     A42,W4
0110C:  MUL.UU  W4,#4,W0
0110E:  MOV     #A10,W4
01110:  ADD     W0,W4,W0
01112:  MOV     #A,W4
01114:  MOV     [W0++],[W4++]
01116:  MOV     [W0++],[W4++]
01118:  MOV     A44,W4
0111A:  MUL.UU  W4,#4,W0
0111C:  MOV     #A10,W4
0111E:  ADD     W0,W4,W0
01120:  MOV     W0,W4
01122:  MOV     #0,W3
01124:  MOV     [W4++],[W3++]
01126:  MOV     [W4++],[W3++]
01128:  MOV     W5,W2
0112A:  MOV     W6,W3
0112C:  CALL    9D4
01130:  BRA     NC,1162
....................                temp = uv_buff[i]; 
01132:  MOV     A42,W4
01134:  MUL.UU  W4,#4,W0
01136:  MOV     #A10,W4
01138:  ADD     W0,W4,W0
0113A:  MOV     #A38,W4
0113C:  MOV     [W0++],[W4++]
0113E:  MOV     [W0++],[W4++]
....................                uv_buff[i] = uv_buff[j]; 
01140:  MOV     A42,W4
01142:  MUL.UU  W4,#4,W0
01144:  MOV     #A10,W4
01146:  ADD     W0,W4,W5
01148:  MOV     A44,W4
0114A:  MUL.UU  W4,#4,W0
0114C:  MOV     #A10,W4
0114E:  ADD     W0,W4,W0
01150:  MOV     [W0++],[W5++]
01152:  MOV     [W0++],[W5++]
....................                uv_buff[j] = temp; 
01154:  MOV     A44,W4
01156:  MUL.UU  W4,#4,W0
01158:  MOV     #A10,W4
0115A:  ADD     W0,W4,W5
0115C:  MOV     #A38,W4
0115E:  MOV     [W4++],[W5++]
01160:  MOV     [W4++],[W5++]
....................             } 
01162:  INC     0A44
01164:  GOTO    1104
....................          } 
01168:  INC     0A42
0116A:  GOTO    10F8
....................       }       
....................       // avg caculation 
....................       avgValue = 0; 
0116E:  CLR     A3C
01170:  CLR     A3E
....................       for (int n = 2; n < 8; n++) 
01172:  MOV     #2,W4
01174:  MOV     W4,A46
01176:  MOV     A46,W4
01178:  CP      W4,#8
0117A:  BRA     GE,11A4
....................          avgValue += uv_buff[n]; 
0117C:  MOV     A46,W4
0117E:  MUL.UU  W4,#4,W0
01180:  MOV     #A10,W4
01182:  ADD     W0,W4,W0
01184:  MOV     W0,W4
01186:  MOV     #0,W3
01188:  MOV     [W4++],[W3++]
0118A:  MOV     [W4++],[W3++]
0118C:  BCLR.B  43.0
0118E:  MOV     W0,W2
01190:  MOV     W1,W3
01192:  MOV     A3C,W0
01194:  MOV     A3E,W1
01196:  CALL    B66
0119A:  MOV     W0,A3C
0119C:  MOV     W1,A3E
0119E:  INC     0A46
011A0:  GOTO    1176
....................    
....................       return avgValue/6; 
011A4:  MOV     A3C,W0
011A6:  MOV     A3E,W1
011A8:  MOV     #0,W2
011AA:  MOV     #40C0,W3
011AC:  CALL    F60
011B0:  MOV.D   W0,W0
011B2:  MOV     [--W15],W6
011B4:  MOV     [--W15],W5
011B6:  RETURN  
.................... } 
....................  
.................... float read_single_UV ()  
*
0102A:  MOV     W5,[W15++]
0102C:  MOV     #C,W5
0102E:  REPEAT  #4
01030:  MOV     [W5++],[W15++]
.................... { 
....................       int ADC_value; 
....................       float ADC_float_value; 
....................       float UV_Result; 
....................        
....................       ADC_value = read_analog(); 
01032:  CALL    E8E
01036:  MOV     W0,A4C
....................       ADC_float_value = (ADC_value - (float)((int)ADC_value%100))/100 + (float)((int)ADC_value%100)/100;  
01038:  MOV     A4C,W4
0103A:  MOV     #64,W3
0103C:  REPEAT  #11
0103E:  DIV.S   W4,W3
01040:  MOV     W1,W0
01042:  CALL    F16
01046:  MOV     W0,W5
01048:  MOV     W1,W6
0104A:  MOV     A4C,W0
0104C:  CALL    F16
01050:  BSET.B  43.0
01052:  MOV     W5,W2
01054:  MOV     W6,W3
01056:  CALL    B66
0105A:  MOV     W0,W7
0105C:  MOV     W1,W8
0105E:  MOV     W7,W0
01060:  MOV     W8,W1
01062:  MOV     #0,W2
01064:  MOV     #42C8,W3
01066:  CALL    F60
0106A:  MOV     W0,W7
0106C:  MOV     W1,W8
0106E:  MOV     A4C,W4
01070:  MOV     #64,W3
01072:  REPEAT  #11
01074:  DIV.S   W4,W3
01076:  MOV     W1,W0
01078:  CALL    F16
0107C:  MOV     W0,W9
0107E:  MOV     W1,W10
01080:  MOV     W9,W0
01082:  MOV     W10,W1
01084:  MOV     #0,W2
01086:  MOV     #42C8,W3
01088:  CALL    F60
0108C:  BCLR.B  43.0
0108E:  MOV     W0,W2
01090:  MOV     W1,W3
01092:  MOV     W7,W0
01094:  MOV     W8,W1
01096:  CALL    B66
0109A:  MOV     W0,A4E
0109C:  MOV     W1,A50
....................       UV_Result = 8*ADC_float_value - 8;   
0109E:  MOV     #0,W0
010A0:  MOV     #4100,W1
010A2:  MOV     A4E,W2
010A4:  MOV     A50,W3
010A6:  CALL    AA2
010AA:  MOV     W0,W5
010AC:  MOV     W1,W6
010AE:  BSET.B  43.0
010B0:  MOV     W5,W0
010B2:  MOV     W6,W1
010B4:  MOV     #0,W2
010B6:  MOV     #4100,W3
010B8:  CALL    B66
010BC:  MOV     W0,A52
010BE:  MOV     W1,A54
....................           
....................       delay_ms(5); 
010C0:  REPEAT  #270E
010C2:  NOP     
....................        
....................       return UV_Result; 
010C4:  MOV     A52,W0
010C6:  MOV     A54,W1
010C8:  MOV     #14,W5
010CA:  REPEAT  #4
010CC:  MOV     [--W15],[W5--]
010CE:  MOV     [--W15],W5
010D0:  RETURN  
....................  
.................... } 
....................  
.................... #include "DHT22.c" 
.................... #BIT Data_1 = 0x02E0.1                       // Pin mapped to PORTF.1 
.................... #BIT DataDir_1 = 0x02DE.1                    // Pin direction mapped to TRISF.1 
....................  
.................... unsigned short k; 
.................... unsigned short T_Byte1, T_Byte2, RH_Byte1, RH_Byte2; 
....................  
.................... void start_signal(){ 
....................   DataDir_1 = 0;    // output cua DSPIC30  // send tin hieu request   
*
011B8:  BCLR.B  2DE.1
....................   Data_1    = 0;  
011BA:  BCLR.B  2E0.1
....................   Delay_ms(25); 
011BC:  REPEAT  #34E
011BE:  NOP     
011C0:  REPEAT  #3FFF
011C2:  NOP     
011C4:  REPEAT  #3FFF
011C6:  NOP     
011C8:  REPEAT  #3FFF
011CA:  NOP     
....................   Data_1    = 1;  
011CC:  BSET.B  2E0.1
....................   Delay_us(30); 
011CE:  REPEAT  #3A
011D0:  NOP     
....................   DataDir_1 = 1;    // input cua DSPIC30 
011D2:  BSET.B  2DE.1
011D4:  RETURN  
.................... } 
.................... unsigned short check_response(){   // kiem tra trong khoang thoi gian 300us data = 1 or 0 th tra ve 0 => data thay doi lien tuc 
....................   k = 150; 
011D6:  MOV.B   #96,W0L
011D8:  MOV.B   W0L,8B6
....................   while(!Data_1){ 
011DA:  BTSC.B  2E0.1
011DC:  BRA     11F0
....................     Delay_us(2); 
011DE:  REPEAT  #2
011E0:  NOP     
....................     k--; 
011E2:  DEC.B   08B6
....................     if(k<1) return 0;  // time out 
011E4:  CP0.B   8B6
011E6:  BRA     NZ,11EC
011E8:  CLR.B   0
011EA:  BRA     120E
011EC:  GOTO    11DA
....................   } 
....................   k = 150; 
011F0:  MOV.B   #96,W0L
011F2:  MOV.B   W0L,8B6
....................   while(Data_1){ 
011F4:  BTSS.B  2E0.1
011F6:  BRA     120A
....................     Delay_us(2); 
011F8:  REPEAT  #2
011FA:  NOP     
....................     k--; 
011FC:  DEC.B   08B6
....................     if(k<1) return 0;   // time out 
011FE:  CP0.B   8B6
01200:  BRA     NZ,1206
01202:  CLR.B   0
01204:  BRA     120E
01206:  GOTO    11F4
....................   } 
....................   return 1; 
0120A:  MOV.B   #1,W0L
0120C:  MOV.B   W0L,0
0120E:  RETURN  
.................... } 
.................... unsigned short Read_Data(){ 
01210:  CLR.B   A12
....................   int i; 
....................   unsigned short num = 0; 
....................   DataDir_1 = 1;             // DSPIC nhan du lieu tai Data pin 
01212:  BSET.B  2DE.1
....................   for (i=0; i<8; i++){ 
01214:  CLR     A10
01216:  MOV     A10,W4
01218:  CP      W4,#8
0121A:  BRA     GE,1240
....................     while(!Data_1); 
0121C:  BTSS.B  2E0.1
0121E:  BRA     121C
....................     Delay_us(40); 
01220:  REPEAT  #4E
01222:  NOP     
....................     if(Data_1) num |= 1<<(7-i); 
01224:  BTSS.B  2E0.1
01226:  BRA     1236
01228:  MOV     #7,W4
0122A:  MOV     A10,W3
0122C:  SUB     W4,W3,W0
0122E:  MOV     W0,W4
01230:  MOV     #1,W0
01232:  SL      W0,W4,W0
01234:  IOR.B   A12
....................     while(Data_1); 
01236:  BTSC.B  2E0.1
01238:  BRA     1236
0123A:  INC     0A10
0123C:  GOTO    1216
....................   } 
....................   return num; 
01240:  MOV.B   A12,W0L
01242:  MOV.B   W0L,0
01244:  RETURN  
.................... } 
....................  
.................... #include "ADS1248.c" 
.................... #ifndef ADC_ADS1248 
....................  
.................... #define ADS1248_SCLK  PIN_F6 
.................... #define ADS1248_DIN   PIN_F8 
.................... #define ADS1248_DOUT  PIN_F7 
.................... #define ADS1248_DRDY  PIN_A14 
.................... #define ADS1248_START PIN_G3 
.................... #define ADS1248_RESET PIN_G2 
.................... #define ADS1248_CS    PIN_A15 
....................  
.................... #endif 
....................  
.................... #use spi(MASTER, SPI1, BAUD=500000, MODE=2, BITS=8, stream=SPI_PORT1) 
....................  
.................... #define MUX0      0x00     //01 
.................... #define VBIAS     0x01 
.................... #define MUX1      0x02 
.................... #define SYS0      0x03 
.................... #define OFC0      0x04 
.................... #define OFC1      0x05 
.................... #define OFC2      0x06 
.................... #define FSC0      0x07 
.................... #define FSC1      0x08     //1B 
.................... #define FSC2      0x09     //40 
.................... #define IDAC0     0x0A     //90 
.................... #define IDAC1     0x0B     //FF 
.................... #define GPIOCFG   0x0C 
.................... #define GPIODIR   0x0D 
.................... #define GPIODAT   0x0E 
....................  
.................... #define ADC_WAKEUP   0x00 
.................... #define ADC_SLEEP    0x02 
.................... #define ADC_SYNC     0x04     // 2nd byte is 0x04, 0x05 
.................... #define ADC_RESET    0x06 
.................... #define ADC_NOP      0xFF 
.................... #define ADC_RDATA    0x12 
.................... #define ADC_RDATAC   0x14 
.................... #define ADC_SDATAC   0x16 
.................... #define ADC_RREG     0x20     // 2nd byte is number of registers to be read (number of bytes  1) 
.................... #define ADC_WREG     0x40     // 2nd byte is number of registers to be written (number of bytes  1) 
.................... #define ADC_SYSOCAL  0x60 
.................... #define ADC_SYSGCAL  0x61 
.................... #define ADC_SELFOCAL 0x62 
....................  
.................... #define LED PIN_C4                                          // Chan led cua DUST 
....................  
.................... //---khai bao bien cua Dust---// 
.................... float read_avg_Dust (); 
.................... float read_single_Dust (); 
....................  
.................... //---khai bao bien cua PH---// 
.................... float read_avg_PH (); 
.................... float read_single_PH (); 
....................  
.................... void ads1248_hard_reset() { 
....................    output_low(ADS1248_RESET); 
....................    delay_us(4); 
....................    output_high(ADS1248_RESET); 
....................    delay_ms(2); 
.................... } 
....................  
.................... void ads1248_soft_reset() { 
....................    output_low(ADS1248_CS); 
....................    spi_write(ADC_RESET); 
....................    delay_ms(2); 
....................    output_high(ADS1248_CS); 
....................    delay_us(2); 
.................... } 
....................  
.................... void Read_all_reg() { 
....................    int8 i, data; 
....................    output_low(ADS1248_CS); 
....................    output_high(ADS1248_START); 
....................    spi_write(ADC_RREG|MUX0);     // Read from register MUX0 
....................    spi_write(0x0D);              // 15 reg 
....................    for(i=0;i<15;++i) { 
....................       data = spi_read(0); 
....................       putc(data); 
....................    } 
....................    output_low(ADS1248_START); 
....................    output_high(ADS1248_CS); 
.................... } 
....................  
.................... void ads1248_init() 
.................... { 
....................    output_low(ADS1248_CS); 
*
0127A:  BCLR.B  2C1.7
0127C:  BCLR.B  2C5.7
....................    delay_ms(1); 
0127E:  REPEAT  #7CE
01280:  NOP     
....................    spi_write(ADC_RESET); 
01282:  BCLR.B  220.6
01284:  BTSS.B  220.0
01286:  BRA     128C
01288:  MOV.B   224,W0L
0128A:  BRA     1284
0128C:  MOV.B   #6,W0L
0128E:  MOV.B   W0L,224
01290:  BTSS.B  220.0
01292:  BRA     1290
....................    delay_ms(2); 
01294:  REPEAT  #F9E
01296:  NOP     
....................    output_high(ADS1248_CS); 
01298:  BCLR.B  2C1.7
0129A:  BSET.B  2C5.7
....................    delay_ms(10); 
0129C:  REPEAT  #E1E
0129E:  NOP     
012A0:  REPEAT  #3FFF
012A2:  NOP     
....................    output_low(ADS1248_CS); 
012A4:  BCLR.B  2C1.7
012A6:  BCLR.B  2C5.7
....................    spi_write(ADC_WREG|MUX0); 
012A8:  BCLR.B  220.6
012AA:  BTSS.B  220.0
012AC:  BRA     12B2
012AE:  MOV.B   224,W0L
012B0:  BRA     12AA
012B2:  MOV.B   #40,W0L
012B4:  MOV.B   W0L,224
012B6:  BTSS.B  220.0
012B8:  BRA     12B6
....................    spi_write(0x03);        // write 4 REG from MUX0 
012BA:  BCLR.B  220.6
012BC:  BTSS.B  220.0
012BE:  BRA     12C4
012C0:  MOV.B   224,W0L
012C2:  BRA     12BC
012C4:  MOV.B   #3,W0L
012C6:  MOV.B   W0L,224
012C8:  BTSS.B  220.0
012CA:  BRA     12C8
....................    spi_write(0x17);        // MUX0  00.010.111 : current source off, P=2,N=7 (connect A7 to GND) 
012CC:  BCLR.B  220.6
012CE:  BTSS.B  220.0
012D0:  BRA     12D6
012D2:  MOV.B   224,W0L
012D4:  BRA     12CE
012D6:  MOV.B   #17,W0L
012D8:  MOV.B   W0L,224
012DA:  BTSS.B  220.0
012DC:  BRA     12DA
....................    spi_write(0x00);        // VBIAS 0000.0000 : Bias Voltage is not set 
012DE:  BCLR.B  220.6
012E0:  BTSS.B  220.0
012E2:  BRA     12E8
012E4:  MOV.B   224,W0L
012E6:  BRA     12E0
012E8:  CLR.B   224
012EA:  BTSS.B  220.0
012EC:  BRA     12EA
....................    spi_write(0x38);        // MUX1  0.01.11.000 : ,Vref internal, Normal operation 
012EE:  BCLR.B  220.6
012F0:  BTSS.B  220.0
012F2:  BRA     12F8
012F4:  MOV.B   224,W0L
012F6:  BRA     12F0
012F8:  MOV.B   #38,W0L
012FA:  MOV.B   W0L,224
012FC:  BTSS.B  220.0
012FE:  BRA     12FC
....................    spi_write(0x08);        // SYS0  0.000.1000 : PGA=1,1000SPS 
01300:  BCLR.B  220.6
01302:  BTSS.B  220.0
01304:  BRA     130A
01306:  MOV.B   224,W0L
01308:  BRA     1302
0130A:  MOV.B   #8,W0L
0130C:  MOV.B   W0L,224
0130E:  BTSS.B  220.0
01310:  BRA     130E
....................    spi_write(ADC_WREG|IDAC0); 
01312:  BCLR.B  220.6
01314:  BTSS.B  220.0
01316:  BRA     131C
01318:  MOV.B   224,W0L
0131A:  BRA     1314
0131C:  MOV.B   #4A,W0L
0131E:  MOV.B   W0L,224
01320:  BTSS.B  220.0
01322:  BRA     1320
....................    spi_write(0x01);        // write 2 REG from IDAC0 
01324:  BCLR.B  220.6
01326:  BTSS.B  220.0
01328:  BRA     132E
0132A:  MOV.B   224,W0L
0132C:  BRA     1326
0132E:  MOV.B   #1,W0L
01330:  MOV.B   W0L,224
01332:  BTSS.B  220.0
01334:  BRA     1332
....................    spi_write(0x07);        // IDAC0 0000.0.111 : current source 15000uA  
01336:  BCLR.B  220.6
01338:  BTSS.B  220.0
0133A:  BRA     1340
0133C:  MOV.B   224,W0L
0133E:  BRA     1338
01340:  MOV.B   #7,W0L
01342:  MOV.B   W0L,224
01344:  BTSS.B  220.0
01346:  BRA     1344
....................    spi_write(0x77);        // IDAC1 0111.0111 : AI7, AI7 
01348:  BCLR.B  220.6
0134A:  BTSS.B  220.0
0134C:  BRA     1352
0134E:  MOV.B   224,W0L
01350:  BRA     134A
01352:  MOV.B   #77,W0L
01354:  MOV.B   W0L,224
01356:  BTSS.B  220.0
01358:  BRA     1356
....................    output_high(ADS1248_CS); 
0135A:  BCLR.B  2C1.7
0135C:  BSET.B  2C5.7
....................    output_low(ADS1248_START); 
0135E:  BCLR.B  2E4.3
01360:  BCLR.B  2E8.3
01362:  RETURN  
.................... } 
....................  
.................... void ads1248_init1() 
.................... { 
....................    output_low(ADS1248_CS); 
*
017E6:  BCLR.B  2C1.7
017E8:  BCLR.B  2C5.7
....................    delay_ms(1); 
017EA:  REPEAT  #7CE
017EC:  NOP     
....................    spi_write(ADC_RESET); 
017EE:  BCLR.B  220.6
017F0:  BTSS.B  220.0
017F2:  BRA     17F8
017F4:  MOV.B   224,W0L
017F6:  BRA     17F0
017F8:  MOV.B   #6,W0L
017FA:  MOV.B   W0L,224
017FC:  BTSS.B  220.0
017FE:  BRA     17FC
....................    delay_ms(2); 
01800:  REPEAT  #F9E
01802:  NOP     
....................    output_high(ADS1248_CS); 
01804:  BCLR.B  2C1.7
01806:  BSET.B  2C5.7
....................    delay_ms(10); 
01808:  REPEAT  #E1E
0180A:  NOP     
0180C:  REPEAT  #3FFF
0180E:  NOP     
....................    output_low(ADS1248_CS); 
01810:  BCLR.B  2C1.7
01812:  BCLR.B  2C5.7
....................    spi_write(ADC_WREG|MUX0); 
01814:  BCLR.B  220.6
01816:  BTSS.B  220.0
01818:  BRA     181E
0181A:  MOV.B   224,W0L
0181C:  BRA     1816
0181E:  MOV.B   #40,W0L
01820:  MOV.B   W0L,224
01822:  BTSS.B  220.0
01824:  BRA     1822
....................    spi_write(0x03);        // write 4 REG from MUX0 
01826:  BCLR.B  220.6
01828:  BTSS.B  220.0
0182A:  BRA     1830
0182C:  MOV.B   224,W0L
0182E:  BRA     1828
01830:  MOV.B   #3,W0L
01832:  MOV.B   W0L,224
01834:  BTSS.B  220.0
01836:  BRA     1834
....................    spi_write(0x0f);        // MUX0  00.001.111 : current source off, P=1,N=7 (connect A7 to GND) 
01838:  BCLR.B  220.6
0183A:  BTSS.B  220.0
0183C:  BRA     1842
0183E:  MOV.B   224,W0L
01840:  BRA     183A
01842:  MOV.B   #F,W0L
01844:  MOV.B   W0L,224
01846:  BTSS.B  220.0
01848:  BRA     1846
....................    spi_write(0x00);        // VBIAS 0000.0000 : Bias Voltage is not set 
0184A:  BCLR.B  220.6
0184C:  BTSS.B  220.0
0184E:  BRA     1854
01850:  MOV.B   224,W0L
01852:  BRA     184C
01854:  CLR.B   224
01856:  BTSS.B  220.0
01858:  BRA     1856
....................    spi_write(0x38);        // MUX1  0.01.11.000 : ,Vref internal, Normal operation 
0185A:  BCLR.B  220.6
0185C:  BTSS.B  220.0
0185E:  BRA     1864
01860:  MOV.B   224,W0L
01862:  BRA     185C
01864:  MOV.B   #38,W0L
01866:  MOV.B   W0L,224
01868:  BTSS.B  220.0
0186A:  BRA     1868
....................    spi_write(0x08);        // SYS0  0.000.1000 : PGA=1,1000SPS    
0186C:  BCLR.B  220.6
0186E:  BTSS.B  220.0
01870:  BRA     1876
01872:  MOV.B   224,W0L
01874:  BRA     186E
01876:  MOV.B   #8,W0L
01878:  MOV.B   W0L,224
0187A:  BTSS.B  220.0
0187C:  BRA     187A
....................    spi_write(ADC_WREG|IDAC0); 
0187E:  BCLR.B  220.6
01880:  BTSS.B  220.0
01882:  BRA     1888
01884:  MOV.B   224,W0L
01886:  BRA     1880
01888:  MOV.B   #4A,W0L
0188A:  MOV.B   W0L,224
0188C:  BTSS.B  220.0
0188E:  BRA     188C
....................    spi_write(0x01);        // write 2 REG from IDAC0 
01890:  BCLR.B  220.6
01892:  BTSS.B  220.0
01894:  BRA     189A
01896:  MOV.B   224,W0L
01898:  BRA     1892
0189A:  MOV.B   #1,W0L
0189C:  MOV.B   W0L,224
0189E:  BTSS.B  220.0
018A0:  BRA     189E
....................    spi_write(0x07);        // IDAC0 0000.0.111 : current source 15000uA  
018A2:  BCLR.B  220.6
018A4:  BTSS.B  220.0
018A6:  BRA     18AC
018A8:  MOV.B   224,W0L
018AA:  BRA     18A4
018AC:  MOV.B   #7,W0L
018AE:  MOV.B   W0L,224
018B0:  BTSS.B  220.0
018B2:  BRA     18B0
....................    spi_write(0x77);        // IDAC1 0111.0111 : AI7, AI7 
018B4:  BCLR.B  220.6
018B6:  BTSS.B  220.0
018B8:  BRA     18BE
018BA:  MOV.B   224,W0L
018BC:  BRA     18B6
018BE:  MOV.B   #77,W0L
018C0:  MOV.B   W0L,224
018C2:  BTSS.B  220.0
018C4:  BRA     18C2
....................    output_high(ADS1248_CS); 
018C6:  BCLR.B  2C1.7
018C8:  BSET.B  2C5.7
....................    output_low(ADS1248_START); 
018CA:  BCLR.B  2E4.3
018CC:  BCLR.B  2E8.3
018CE:  RETURN  
.................... } 
.................... int32 convert_24bits(int32 value) { 
....................    if(value > 0x7FFFFF) { 
*
01364:  MOV     A62,W4
01366:  MOV     #7F,W3
01368:  CP      W3,W4
0136A:  BRA     GT,1388
0136C:  BRA     LT,1376
0136E:  MOV     A60,W4
01370:  MOV     #FFFF,W3
01372:  CP      W3,W4
01374:  BRA     C,1388
....................       return (value - 0x800000); 
01376:  MOV     A60,W4
01378:  SUB     W4,#0,W0
0137A:  MOV     A62,W4
0137C:  SUBB    #80,W4
0137E:  MOV     W4,W1
01380:  MOV.D   W0,W0
01382:  BRA     1398
....................       //return 0; 
....................    } else { 
01384:  GOTO    1398
....................       return (value + 0x800000); 
01388:  MOV     A60,W4
0138A:  ADD     W4,#0,W4
0138C:  MOV     W4,W0
0138E:  MOV     #80,W4
01390:  MOV     A62,W3
01392:  ADDC    W3,W4,W1
01394:  MOV.D   W0,W0
01396:  BRA     1398
....................       //return value; 
....................    } 
01398:  RETURN  
.................... } 
....................  
.................... int32 ads1248_read_adc() { 
*
018D0:  MOV     W5,[W15++]
018D2:  MOV     W6,[W15++]
....................    int8 MSB, MID, LSB; 
....................    output_low(ADS1248_CS); 
018D4:  BCLR.B  2C1.7
018D6:  BCLR.B  2C5.7
....................    output_high(ADS1248_START); 
018D8:  BCLR.B  2E4.3
018DA:  BSET.B  2E8.3
....................    delay_us(2); 
018DC:  REPEAT  #2
018DE:  NOP     
....................    output_low(ADS1248_START); 
018E0:  BCLR.B  2E4.3
018E2:  BCLR.B  2E8.3
....................    while(input(ADS1248_DRDY) == 1); 
018E4:  BSET.B  2C1.6
018E6:  BTSC.B  2C3.6
018E8:  BRA     18E4
....................    spi_write(ADC_RDATA); 
018EA:  BCLR.B  220.6
018EC:  BTSS.B  220.0
018EE:  BRA     18F4
018F0:  MOV.B   224,W0L
018F2:  BRA     18EC
018F4:  MOV.B   #12,W0L
018F6:  MOV.B   W0L,224
018F8:  BTSS.B  220.0
018FA:  BRA     18F8
....................    delay_us(1); 
018FC:  REPEAT  #0
018FE:  NOP     
....................    MSB = spi_read(1); 
01900:  BCLR.B  220.6
01902:  BTSS.B  220.0
01904:  BRA     190A
01906:  MOV.B   224,W0L
01908:  BRA     1902
0190A:  MOV.B   #1,W0L
0190C:  MOV.B   W0L,224
0190E:  BTSS.B  220.0
01910:  BRA     190E
01912:  MOV.B   224,W0L
01914:  MOV.B   W0L,A58
....................    MID = spi_read(1); 
01916:  BCLR.B  220.6
01918:  BTSS.B  220.0
0191A:  BRA     1920
0191C:  MOV.B   224,W0L
0191E:  BRA     1918
01920:  MOV.B   #1,W0L
01922:  MOV.B   W0L,224
01924:  BTSS.B  220.0
01926:  BRA     1924
01928:  MOV.B   224,W0L
0192A:  MOV.B   W0L,A59
....................    LSB = spi_read(1); 
0192C:  BCLR.B  220.6
0192E:  BTSS.B  220.0
01930:  BRA     1936
01932:  MOV.B   224,W0L
01934:  BRA     192E
01936:  MOV.B   #1,W0L
01938:  MOV.B   W0L,224
0193A:  BTSS.B  220.0
0193C:  BRA     193A
0193E:  MOV.B   224,W0L
01940:  MOV.B   W0L,A5A
....................    //printf("%d %d %d \n", MSB,MID,LSB); 
....................    output_high(ADS1248_CS); 
01942:  BCLR.B  2C1.7
01944:  BSET.B  2C5.7
....................    return convert_24bits(make32(0,MSB,MID,LSB)); 
01946:  CLR.B   D
01948:  MOV.B   A58,W0L
0194A:  MOV.B   W0L,E
0194C:  MOV.B   A59,W0L
0194E:  MOV.B   W0L,W0L
01950:  MOV.B   W0L,B
01952:  MOV.B   A5A,W0L
01954:  MOV.B   W0L,A
01956:  MOV     W5,A60
01958:  MOV     W6,A62
0195A:  CALL    1364
0195E:  MOV.D   W0,W0
01960:  MOV     [--W15],W6
01962:  MOV     [--W15],W5
01964:  RETURN  
.................... } 
.................... int32 ads1248_read_adc1() { 
*
0139A:  MOV     W5,[W15++]
0139C:  MOV     W6,[W15++]
....................    int8 MSB1, MID1, LSB1; 
....................    output_low(ADS1248_CS); 
0139E:  BCLR.B  2C1.7
013A0:  BCLR.B  2C5.7
....................    output_high(ADS1248_START); 
013A2:  BCLR.B  2E4.3
013A4:  BSET.B  2E8.3
....................    delay_us(2); 
013A6:  REPEAT  #2
013A8:  NOP     
....................    output_low(ADS1248_START); 
013AA:  BCLR.B  2E4.3
013AC:  BCLR.B  2E8.3
....................    while(input(ADS1248_DRDY) == 1); 
013AE:  BSET.B  2C1.6
013B0:  BTSC.B  2C3.6
013B2:  BRA     13AE
....................    spi_write(ADC_RDATA); 
013B4:  BCLR.B  220.6
013B6:  BTSS.B  220.0
013B8:  BRA     13BE
013BA:  MOV.B   224,W0L
013BC:  BRA     13B6
013BE:  MOV.B   #12,W0L
013C0:  MOV.B   W0L,224
013C2:  BTSS.B  220.0
013C4:  BRA     13C2
....................    delay_us(1); 
013C6:  REPEAT  #0
013C8:  NOP     
....................    MSB1 = spi_read(2); 
013CA:  BCLR.B  220.6
013CC:  BTSS.B  220.0
013CE:  BRA     13D4
013D0:  MOV.B   224,W0L
013D2:  BRA     13CC
013D4:  MOV.B   #2,W0L
013D6:  MOV.B   W0L,224
013D8:  BTSS.B  220.0
013DA:  BRA     13D8
013DC:  MOV.B   224,W0L
013DE:  MOV.B   W0L,A58
....................    MID1 = spi_read(2); 
013E0:  BCLR.B  220.6
013E2:  BTSS.B  220.0
013E4:  BRA     13EA
013E6:  MOV.B   224,W0L
013E8:  BRA     13E2
013EA:  MOV.B   #2,W0L
013EC:  MOV.B   W0L,224
013EE:  BTSS.B  220.0
013F0:  BRA     13EE
013F2:  MOV.B   224,W0L
013F4:  MOV.B   W0L,A59
....................    LSB1 = spi_read(2); 
013F6:  BCLR.B  220.6
013F8:  BTSS.B  220.0
013FA:  BRA     1400
013FC:  MOV.B   224,W0L
013FE:  BRA     13F8
01400:  MOV.B   #2,W0L
01402:  MOV.B   W0L,224
01404:  BTSS.B  220.0
01406:  BRA     1404
01408:  MOV.B   224,W0L
0140A:  MOV.B   W0L,A5A
....................    //printf("%d %d %d \n", MSB,MID,LSB); 
....................    output_high(ADS1248_CS); 
0140C:  BCLR.B  2C1.7
0140E:  BSET.B  2C5.7
....................    return convert_24bits(make32(0,MSB1,MID1,LSB1)); 
01410:  CLR.B   D
01412:  MOV.B   A58,W0L
01414:  MOV.B   W0L,E
01416:  MOV.B   A59,W0L
01418:  MOV.B   W0L,W0L
0141A:  MOV.B   W0L,B
0141C:  MOV.B   A5A,W0L
0141E:  MOV.B   W0L,A
01420:  MOV     W5,A60
01422:  MOV     W6,A62
01424:  CALL    1364
01428:  MOV.D   W0,W0
0142A:  MOV     [--W15],W6
0142C:  MOV     [--W15],W5
0142E:  RETURN  
.................... } 
....................  
.................... //---------Reset-------------// 
.................... void ADC_reset_REG() 
.................... { 
....................    output_low(ADS1248_RESET); 
*
01246:  BCLR.B  2E4.2
01248:  BCLR.B  2E8.2
....................    delay_us(4); 
0124A:  REPEAT  #6
0124C:  NOP     
....................    output_high(ADS1248_RESET); 
0124E:  BCLR.B  2E4.2
01250:  BSET.B  2E8.2
....................    delay_ms(2); 
01252:  REPEAT  #F9E
01254:  NOP     
....................    output_low(ADS1248_CS); 
01256:  BCLR.B  2C1.7
01258:  BCLR.B  2C5.7
....................    spi_write(ADC_RESET); 
0125A:  BCLR.B  220.6
0125C:  BTSS.B  220.0
0125E:  BRA     1264
01260:  MOV.B   224,W0L
01262:  BRA     125C
01264:  MOV.B   #6,W0L
01266:  MOV.B   W0L,224
01268:  BTSS.B  220.0
0126A:  BRA     1268
....................    delay_ms(2); 
0126C:  REPEAT  #F9E
0126E:  NOP     
....................    output_high(ADS1248_CS); 
01270:  BCLR.B  2C1.7
01272:  BSET.B  2C5.7
....................    delay_us(2); 
01274:  REPEAT  #2
01276:  NOP     
01278:  RETURN  
.................... } 
....................  
.................... //---------DUST-------------// 
.................... float read_avg_Dust () 
*
01700:  MOV     W5,[W15++]
01702:  MOV     W6,[W15++]
.................... { 
....................    float dust_buff[10]; 
....................    float temp; 
....................    float avgValue; 
....................     
....................       // read 10 sample 
....................      for (int k = 0; k < 10; k++){ 
01704:  CLR     A40
01706:  MOV     A40,W4
01708:  CP      W4,#A
0170A:  BRA     GE,1724
....................          dust_buff[k] = read_single_Dust(); 
0170C:  MOV     A40,W4
0170E:  MUL.UU  W4,#4,W0
01710:  MOV     #A10,W4
01712:  ADD     W0,W4,W5
01714:  CALL    161E
01718:  MOV     #0,W4
0171A:  MOV     [W4++],[W5++]
0171C:  MOV     [W4++],[W5++]
0171E:  INC     0A40
01720:  GOTO    1706
....................       } 
....................       // sort 10 sample 
....................       for (int i = 0; i < 9; i++){ 
01724:  CLR     A42
01726:  MOV     A42,W4
01728:  CP      W4,#9
0172A:  BRA     GE,179C
....................          for (int j = i + 1; j < 10; j++){ 
0172C:  MOV     A42,W4
0172E:  ADD     W4,#1,W4
01730:  MOV     W4,A44
01732:  MOV     A44,W4
01734:  CP      W4,#A
01736:  BRA     GE,1796
....................             if (dust_buff[i] > dust_buff[j]){ 
01738:  MOV     A42,W4
0173A:  MUL.UU  W4,#4,W0
0173C:  MOV     #A10,W4
0173E:  ADD     W0,W4,W0
01740:  MOV     #A,W4
01742:  MOV     [W0++],[W4++]
01744:  MOV     [W0++],[W4++]
01746:  MOV     A44,W4
01748:  MUL.UU  W4,#4,W0
0174A:  MOV     #A10,W4
0174C:  ADD     W0,W4,W0
0174E:  MOV     W0,W4
01750:  MOV     #0,W3
01752:  MOV     [W4++],[W3++]
01754:  MOV     [W4++],[W3++]
01756:  MOV     W5,W2
01758:  MOV     W6,W3
0175A:  CALL    9D4
0175E:  BRA     NC,1790
....................                temp = dust_buff[i]; 
01760:  MOV     A42,W4
01762:  MUL.UU  W4,#4,W0
01764:  MOV     #A10,W4
01766:  ADD     W0,W4,W0
01768:  MOV     #A38,W4
0176A:  MOV     [W0++],[W4++]
0176C:  MOV     [W0++],[W4++]
....................                dust_buff[i] = dust_buff[j]; 
0176E:  MOV     A42,W4
01770:  MUL.UU  W4,#4,W0
01772:  MOV     #A10,W4
01774:  ADD     W0,W4,W5
01776:  MOV     A44,W4
01778:  MUL.UU  W4,#4,W0
0177A:  MOV     #A10,W4
0177C:  ADD     W0,W4,W0
0177E:  MOV     [W0++],[W5++]
01780:  MOV     [W0++],[W5++]
....................                dust_buff[j] = temp; 
01782:  MOV     A44,W4
01784:  MUL.UU  W4,#4,W0
01786:  MOV     #A10,W4
01788:  ADD     W0,W4,W5
0178A:  MOV     #A38,W4
0178C:  MOV     [W4++],[W5++]
0178E:  MOV     [W4++],[W5++]
....................             } 
01790:  INC     0A44
01792:  GOTO    1732
....................          } 
01796:  INC     0A42
01798:  GOTO    1726
....................       }       
....................       // avg caculation 
....................       avgValue = 0; 
0179C:  CLR     A3C
0179E:  CLR     A3E
....................       for (int n = 2; n < 8; n++) 
017A0:  MOV     #2,W4
017A2:  MOV     W4,A46
017A4:  MOV     A46,W4
017A6:  CP      W4,#8
017A8:  BRA     GE,17D2
....................          avgValue += dust_buff[n]; 
017AA:  MOV     A46,W4
017AC:  MUL.UU  W4,#4,W0
017AE:  MOV     #A10,W4
017B0:  ADD     W0,W4,W0
017B2:  MOV     W0,W4
017B4:  MOV     #0,W3
017B6:  MOV     [W4++],[W3++]
017B8:  MOV     [W4++],[W3++]
017BA:  BCLR.B  43.0
017BC:  MOV     W0,W2
017BE:  MOV     W1,W3
017C0:  MOV     A3C,W0
017C2:  MOV     A3E,W1
017C4:  CALL    B66
017C8:  MOV     W0,A3C
017CA:  MOV     W1,A3E
017CC:  INC     0A46
017CE:  GOTO    17A4
....................    
....................       return avgValue/6; 
017D2:  MOV     A3C,W0
017D4:  MOV     A3E,W1
017D6:  MOV     #0,W2
017D8:  MOV     #40C0,W3
017DA:  CALL    F60
017DE:  MOV.D   W0,W0
017E0:  MOV     [--W15],W6
017E2:  MOV     [--W15],W5
017E4:  RETURN  
.................... } 
....................  
.................... float read_single_Dust () 
*
0161E:  MOV     W5,[W15++]
01620:  MOV     W6,[W15++]
01622:  MOV     W7,[W15++]
01624:  MOV     W8,[W15++]
.................... { 
....................       int32 ADC_value; 
....................       float ADC_float_value; 
....................       float Dust_Result; 
....................        
....................       ADC_reset_REG(); 
01626:  CALL    1246
....................       ads1248_init(); 
0162A:  CALL    127A
....................        
....................       output_low(LED); 
0162E:  BCLR.B  2CC.4
01630:  BCLR.B  2D0.4
....................       delay_us(280); 
01632:  REPEAT  #22E
01634:  NOP     
....................       ADC_value = ads1248_read_adc1(); 
01636:  CALL    139A
0163A:  MOV     W0,A4C
0163C:  MOV     W1,A4E
....................       delay_us(40); 
0163E:  REPEAT  #4E
01640:  NOP     
....................       output_high(LED); 
01642:  BCLR.B  2CC.4
01644:  BSET.B  2D0.4
....................       delay_us(9680); 
01646:  REPEAT  #B9E
01648:  NOP     
0164A:  REPEAT  #3FFF
0164C:  NOP     
....................        
....................       ADC_float_value = ADC_value / 8388608.0 * 2.048-(2.048-2.020); 
0164E:  MOV     A4C,W0
01650:  MOV     A4E,W1
01652:  CLR     W3
01654:  BTSC    W1.F
01656:  SETM    W3
01658:  MOV     W3,W2
0165A:  CALL    714
0165E:  MOV     #0,W4
01660:  MOV     #0,W5
01662:  MOV     #0,W6
01664:  MOV     #4160,W7
01666:  CALL    888
0166A:  MOV     W0,W5
0166C:  MOV     W1,W6
0166E:  MOV     W2,W7
01670:  MOV     W3,W8
01672:  MOV     W5,[W15++]
01674:  MOV     W6,[W15++]
01676:  MOV     W7,[W15++]
01678:  MOV     W5,W0
0167A:  MOV     W6,W1
0167C:  MOV     W7,W2
0167E:  MOV     W8,W3
01680:  MOV     #A9FC,W4
01682:  MOV     #D2F1,W5
01684:  MOV     #624D,W6
01686:  MOV     #4000,W7
01688:  CALL    778
0168C:  MOV     [--W15],W7
0168E:  MOV     [--W15],W6
01690:  MOV     [--W15],W5
01692:  MOV     W0,W5
01694:  MOV     W1,W6
01696:  MOV     W2,W7
01698:  MOV     W3,W8
0169A:  BSET.B  43.0
0169C:  MOV     W5,[W15++]
0169E:  MOV     W6,[W15++]
016A0:  MOV     W7,[W15++]
016A2:  MOV     W5,W0
016A4:  MOV     W6,W1
016A6:  MOV     W7,W2
016A8:  MOV     W8,W3
016AA:  MOV     #E980,W4
016AC:  MOV     #3126,W5
016AE:  MOV     #AC08,W6
016B0:  MOV     #3F9C,W7
016B2:  CALL    1430
016B6:  MOV     [--W15],W7
016B8:  MOV     [--W15],W6
016BA:  MOV     [--W15],W5
016BC:  CALL    990
016C0:  MOV     W1,A50
016C2:  MOV     W2,A52
....................        
....................       Dust_Result = 0.17*ADC_float_value-0.1; 
016C4:  MOV     #147B,W0
016C6:  MOV     #3E2E,W1
016C8:  MOV     A50,W2
016CA:  MOV     A52,W3
016CC:  CALL    AA2
016D0:  MOV     W0,W5
016D2:  MOV     W1,W6
016D4:  BSET.B  43.0
016D6:  MOV     W5,W0
016D8:  MOV     W6,W1
016DA:  MOV     #CCCD,W2
016DC:  MOV     #3DCC,W3
016DE:  CALL    B66
016E2:  MOV     W0,A54
016E4:  MOV     W1,A56
....................       
....................       delay_ms(20); 
016E6:  REPEAT  #1C3E
016E8:  NOP     
016EA:  REPEAT  #3FFF
016EC:  NOP     
016EE:  REPEAT  #3FFF
016F0:  NOP     
....................        
....................       return Dust_Result; 
016F2:  MOV     A54,W0
016F4:  MOV     A56,W1
016F6:  MOV     [--W15],W8
016F8:  MOV     [--W15],W7
016FA:  MOV     [--W15],W6
016FC:  MOV     [--W15],W5
016FE:  RETURN  
.................... } 
....................  
.................... //---------PH-------------// 
.................... float read_avg_PH () 
*
01A28:  MOV     W5,[W15++]
01A2A:  MOV     W6,[W15++]
.................... { 
....................    float PH_buff[10]; 
....................    float temp; 
....................    float avgValue; 
....................     
....................       // read 10 sample 
....................      for (int k = 0; k < 10; k++){ 
01A2C:  CLR     A40
01A2E:  MOV     A40,W4
01A30:  CP      W4,#A
01A32:  BRA     GE,1A4C
....................         PH_buff[k] = read_single_PH(); 
01A34:  MOV     A40,W4
01A36:  MUL.UU  W4,#4,W0
01A38:  MOV     #A10,W4
01A3A:  ADD     W0,W4,W5
01A3C:  CALL    1966
01A40:  MOV     #0,W4
01A42:  MOV     [W4++],[W5++]
01A44:  MOV     [W4++],[W5++]
01A46:  INC     0A40
01A48:  GOTO    1A2E
....................       } 
....................       // sort 10 sample 
....................       for (int i = 0; i < 9; i++){ 
01A4C:  CLR     A42
01A4E:  MOV     A42,W4
01A50:  CP      W4,#9
01A52:  BRA     GE,1AC4
....................          for (int j = i + 1; j < 10; j++){ 
01A54:  MOV     A42,W4
01A56:  ADD     W4,#1,W4
01A58:  MOV     W4,A44
01A5A:  MOV     A44,W4
01A5C:  CP      W4,#A
01A5E:  BRA     GE,1ABE
....................             if (PH_buff[i] > PH_buff[j]){ 
01A60:  MOV     A42,W4
01A62:  MUL.UU  W4,#4,W0
01A64:  MOV     #A10,W4
01A66:  ADD     W0,W4,W0
01A68:  MOV     #A,W4
01A6A:  MOV     [W0++],[W4++]
01A6C:  MOV     [W0++],[W4++]
01A6E:  MOV     A44,W4
01A70:  MUL.UU  W4,#4,W0
01A72:  MOV     #A10,W4
01A74:  ADD     W0,W4,W0
01A76:  MOV     W0,W4
01A78:  MOV     #0,W3
01A7A:  MOV     [W4++],[W3++]
01A7C:  MOV     [W4++],[W3++]
01A7E:  MOV     W5,W2
01A80:  MOV     W6,W3
01A82:  CALL    9D4
01A86:  BRA     NC,1AB8
....................                temp = PH_buff[i]; 
01A88:  MOV     A42,W4
01A8A:  MUL.UU  W4,#4,W0
01A8C:  MOV     #A10,W4
01A8E:  ADD     W0,W4,W0
01A90:  MOV     #A38,W4
01A92:  MOV     [W0++],[W4++]
01A94:  MOV     [W0++],[W4++]
....................                PH_buff[i] = PH_buff[j]; 
01A96:  MOV     A42,W4
01A98:  MUL.UU  W4,#4,W0
01A9A:  MOV     #A10,W4
01A9C:  ADD     W0,W4,W5
01A9E:  MOV     A44,W4
01AA0:  MUL.UU  W4,#4,W0
01AA2:  MOV     #A10,W4
01AA4:  ADD     W0,W4,W0
01AA6:  MOV     [W0++],[W5++]
01AA8:  MOV     [W0++],[W5++]
....................                PH_buff[j] = temp; 
01AAA:  MOV     A44,W4
01AAC:  MUL.UU  W4,#4,W0
01AAE:  MOV     #A10,W4
01AB0:  ADD     W0,W4,W5
01AB2:  MOV     #A38,W4
01AB4:  MOV     [W4++],[W5++]
01AB6:  MOV     [W4++],[W5++]
....................             } 
01AB8:  INC     0A44
01ABA:  GOTO    1A5A
....................          } 
01ABE:  INC     0A42
01AC0:  GOTO    1A4E
....................       }       
....................       // avg caculation 
....................       avgValue = 0; 
01AC4:  CLR     A3C
01AC6:  CLR     A3E
....................       for (int n = 2; n < 8; n++){ 
01AC8:  MOV     #2,W4
01ACA:  MOV     W4,A46
01ACC:  MOV     A46,W4
01ACE:  CP      W4,#8
01AD0:  BRA     GE,1AFA
....................          avgValue += PH_buff[n]; 
01AD2:  MOV     A46,W4
01AD4:  MUL.UU  W4,#4,W0
01AD6:  MOV     #A10,W4
01AD8:  ADD     W0,W4,W0
01ADA:  MOV     W0,W4
01ADC:  MOV     #0,W3
01ADE:  MOV     [W4++],[W3++]
01AE0:  MOV     [W4++],[W3++]
01AE2:  BCLR.B  43.0
01AE4:  MOV     W0,W2
01AE6:  MOV     W1,W3
01AE8:  MOV     A3C,W0
01AEA:  MOV     A3E,W1
01AEC:  CALL    B66
01AF0:  MOV     W0,A3C
01AF2:  MOV     W1,A3E
01AF4:  INC     0A46
01AF6:  GOTO    1ACC
....................       } 
....................       return avgValue/6; 
01AFA:  MOV     A3C,W0
01AFC:  MOV     A3E,W1
01AFE:  MOV     #0,W2
01B00:  MOV     #40C0,W3
01B02:  CALL    F60
01B06:  MOV.D   W0,W0
01B08:  MOV     [--W15],W6
01B0A:  MOV     [--W15],W5
01B0C:  RETURN  
.................... } 
....................  
.................... float read_single_PH () 
*
01966:  MOV     W5,[W15++]
01968:  MOV     W6,[W15++]
0196A:  MOV     W7,[W15++]
0196C:  MOV     W8,[W15++]
.................... { 
....................       int32 ADC_value; 
....................       float ADC_float_value; 
....................       float PH_Result; 
....................        
....................       ADC_reset_REG(); 
0196E:  CALL    1246
....................       ads1248_init1(); 
01972:  CALL    17E6
....................        
....................       ADC_value = ads1248_read_adc(); 
01976:  CALL    18D0
0197A:  MOV     W0,A4C
0197C:  MOV     W1,A4E
....................       ADC_float_value = ADC_value / 8388608.0 * 2.048-(2.048-2.020); 
0197E:  MOV     A4C,W0
01980:  MOV     A4E,W1
01982:  CLR     W3
01984:  BTSC    W1.F
01986:  SETM    W3
01988:  MOV     W3,W2
0198A:  CALL    714
0198E:  MOV     #0,W4
01990:  MOV     #0,W5
01992:  MOV     #0,W6
01994:  MOV     #4160,W7
01996:  CALL    888
0199A:  MOV     W0,W5
0199C:  MOV     W1,W6
0199E:  MOV     W2,W7
019A0:  MOV     W3,W8
019A2:  MOV     W5,[W15++]
019A4:  MOV     W6,[W15++]
019A6:  MOV     W7,[W15++]
019A8:  MOV     W5,W0
019AA:  MOV     W6,W1
019AC:  MOV     W7,W2
019AE:  MOV     W8,W3
019B0:  MOV     #A9FC,W4
019B2:  MOV     #D2F1,W5
019B4:  MOV     #624D,W6
019B6:  MOV     #4000,W7
019B8:  CALL    778
019BC:  MOV     [--W15],W7
019BE:  MOV     [--W15],W6
019C0:  MOV     [--W15],W5
019C2:  MOV     W0,W5
019C4:  MOV     W1,W6
019C6:  MOV     W2,W7
019C8:  MOV     W3,W8
019CA:  BSET.B  43.0
019CC:  MOV     W5,[W15++]
019CE:  MOV     W6,[W15++]
019D0:  MOV     W7,[W15++]
019D2:  MOV     W5,W0
019D4:  MOV     W6,W1
019D6:  MOV     W7,W2
019D8:  MOV     W8,W3
019DA:  MOV     #E980,W4
019DC:  MOV     #3126,W5
019DE:  MOV     #AC08,W6
019E0:  MOV     #3F9C,W7
019E2:  CALL    1430
019E6:  MOV     [--W15],W7
019E8:  MOV     [--W15],W6
019EA:  MOV     [--W15],W5
019EC:  CALL    990
019F0:  MOV     W1,A50
019F2:  MOV     W2,A52
....................       PH_Result= -5.70*ADC_float_value + 21.34; 
019F4:  MOV     #6666,W0
019F6:  MOV     #C0B6,W1
019F8:  MOV     A50,W2
019FA:  MOV     A52,W3
019FC:  CALL    AA2
01A00:  MOV     W0,W5
01A02:  MOV     W1,W6
01A04:  BCLR.B  43.0
01A06:  MOV     W5,W0
01A08:  MOV     W6,W1
01A0A:  MOV     #B852,W2
01A0C:  MOV     #41AA,W3
01A0E:  CALL    B66
01A12:  MOV     W0,A54
01A14:  MOV     W1,A56
....................        
....................      // PH_Result = 0.17*ADC_float_value-0.1; 
....................       
....................       delay_ms(5); 
01A16:  REPEAT  #270E
01A18:  NOP     
....................        
....................       return PH_Result; 
01A1A:  MOV     A54,W0
01A1C:  MOV     A56,W1
01A1E:  MOV     [--W15],W8
01A20:  MOV     [--W15],W7
01A22:  MOV     [--W15],W6
01A24:  MOV     [--W15],W5
01A26:  RETURN  
....................  
.................... } 
....................  
....................  
.................... //----------------Broker-------------------- 
.................... //#define BROKER_ADDR            "broker.mqttdashboard.com" // Broker Address 
.................... #define BROKER_ADDR              "mqtt.jwclab.com" 
.................... #define BROKER_PORT              "1883"                     // Broker Port   
.................... #define BROKER_TOPIC             "jwclab/demo_station"       // Broker Tocpic eqm_stations 
.................... //---------------Connect define------------- 
.................... #define CONTROL_BYTE_CON         0x10                       // Control Bye of Publish 
.................... #define PACKET_LEN_CON           0x12                       // Length of Packet 
.................... #define PRO_NAME_LEN_MSB_CON     0x00                       // Protocol Name Length (MSB) 
.................... #define PRO_NAME_CON             "MQTT"                     // Protocol Name 
.................... #define PRO_TCP_IPV4             0x04                       // TCP : IPV4 
.................... #define FLAG_CONNCECT            0x02                       // Connect Flags 
.................... #define KEEP_ALIVE_MSB           0x00                       // Keep Live (MSB) 
.................... #define KEEP_ALIVE_LSB           0x3C                       // Keep Live (LSB) 
.................... #define CLIENT_IDEN_LEN_MSB      0x00                       // Client Identifier Length (MSB) 
.................... #define CLIENT_NAME_CON          "ABCDEF"                   // Client name 
.................... //---------------Publish define------------- 
.................... #define CONTROL_BYTE_PUB         0x30                       // Control Bye of Publish 
.................... #define PRO_NAME_LEN_MSB_PUB     0x00                       // Protocol Name Length (MSB) 
....................  
.................... #define ENTER 0x1A                                          // Ky tu Enter 
.................... #use fast_io(F)                                             // Ket noi giua DHT22 voi port F 
....................  
.................... float UV; 
.................... float Dust; 
.................... float PH; 
.................... float tmp, hum; 
....................  
.................... //-------------random------------------------ 
.................... int random(int minN, int maxN){ 
....................     return minN + rand() % (maxN + 1 - minN); 
.................... } 
....................  
.................... //******************AT COMMANDS************************************** 
.................... void AT_Commands(){ 
....................    printf("AT+CIPCLOSE");                          
*
003B8:  MOV     #0,W1
003BA:  MOV     W1,W0
003BC:  CLR.B   1
003BE:  CALL    100
003C2:  INC     W1,W1
003C4:  BTSC.B  20F.1
003C6:  BRA     3C4
003C8:  MOV     W0,210
003CA:  MOV     #A,W0
003CC:  CPSGT   W1,W0
003CE:  BRA     3BA
....................    putc(13,UART_PORT2);  
003D0:  MOV.B   #D,W0L
003D2:  BTSC.B  219.1
003D4:  BRA     3D2
003D6:  MOV.B   W0L,21A
003D8:  CLR.B   21B
....................    delay_ms(500); 
003DA:  MOV     #1F4,W0
003DC:  CALL    378
....................  
....................    printf("AT");                              
003E0:  BTSC.B  219.1
003E2:  BRA     3E0
003E4:  MOV     #41,W4
003E6:  MOV     W4,21A
003E8:  BTSC.B  219.1
003EA:  BRA     3E8
003EC:  MOV     #54,W4
003EE:  MOV     W4,21A
....................    putc(13,UART_PORT2); 
003F0:  MOV.B   #D,W0L
003F2:  BTSC.B  219.1
003F4:  BRA     3F2
003F6:  MOV.B   W0L,21A
003F8:  CLR.B   21B
....................    delay_ms(500); 
003FA:  MOV     #1F4,W0
003FC:  CALL    378
....................  
....................    printf("AT+CREG?");                      
00400:  MOV     #0,W1
00402:  MOV     W1,W0
00404:  CLR.B   1
00406:  CALL    118
0040A:  INC     W1,W1
0040C:  BTSC.B  219.1
0040E:  BRA     40C
00410:  MOV     W0,21A
00412:  MOV     #7,W0
00414:  CPSGT   W1,W0
00416:  BRA     402
....................    putc(13,UART_PORT2); 
00418:  MOV.B   #D,W0L
0041A:  BTSC.B  219.1
0041C:  BRA     41A
0041E:  MOV.B   W0L,21A
00420:  CLR.B   21B
....................    delay_ms(500); 
00422:  MOV     #1F4,W0
00424:  CALL    378
....................  
....................    printf("AT+CGATT?");                       
00428:  MOV     #0,W1
0042A:  MOV     W1,W0
0042C:  CLR.B   1
0042E:  CALL    12E
00432:  INC     W1,W1
00434:  BTSC.B  219.1
00436:  BRA     434
00438:  MOV     W0,21A
0043A:  MOV     #8,W0
0043C:  CPSGT   W1,W0
0043E:  BRA     42A
....................    putc(13,UART_PORT2); 
00440:  MOV.B   #D,W0L
00442:  BTSC.B  219.1
00444:  BRA     442
00446:  MOV.B   W0L,21A
00448:  CLR.B   21B
....................    delay_ms(500); 
0044A:  MOV     #1F4,W0
0044C:  CALL    378
....................  
....................    printf("AT+CIPSHUT");  
00450:  MOV     #0,W1
00452:  MOV     W1,W0
00454:  CLR.B   1
00456:  CALL    144
0045A:  INC     W1,W1
0045C:  BTSC.B  219.1
0045E:  BRA     45C
00460:  MOV     W0,21A
00462:  MOV     #9,W0
00464:  CPSGT   W1,W0
00466:  BRA     452
....................    putc(13,UART_PORT2); 
00468:  MOV.B   #D,W0L
0046A:  BTSC.B  219.1
0046C:  BRA     46A
0046E:  MOV.B   W0L,21A
00470:  CLR.B   21B
....................    delay_ms(500); 
00472:  MOV     #1F4,W0
00474:  CALL    378
....................  
....................    printf("AT+CSTT=\"www\",\"\",\"\" ");  
00478:  MOV     #0,W1
0047A:  MOV     W1,W0
0047C:  CLR.B   1
0047E:  CALL    15C
00482:  INC     W1,W1
00484:  BTSC.B  219.1
00486:  BRA     484
00488:  MOV     W0,21A
0048A:  MOV     #13,W0
0048C:  CPSGT   W1,W0
0048E:  BRA     47A
....................    putc(13,UART_PORT2); 
00490:  MOV.B   #D,W0L
00492:  BTSC.B  219.1
00494:  BRA     492
00496:  MOV.B   W0L,21A
00498:  CLR.B   21B
....................    delay_ms(1000); 
0049A:  MOV     #3E8,W0
0049C:  CALL    378
....................  
....................    printf("AT+CIICR");  
004A0:  MOV     #0,W1
004A2:  MOV     W1,W0
004A4:  CLR.B   1
004A6:  CALL    17E
004AA:  INC     W1,W1
004AC:  BTSC.B  219.1
004AE:  BRA     4AC
004B0:  MOV     W0,21A
004B2:  MOV     #7,W0
004B4:  CPSGT   W1,W0
004B6:  BRA     4A2
....................    putc(13,UART_PORT2); 
004B8:  MOV.B   #D,W0L
004BA:  BTSC.B  219.1
004BC:  BRA     4BA
004BE:  MOV.B   W0L,21A
004C0:  CLR.B   21B
....................    delay_ms(500); 
004C2:  MOV     #1F4,W0
004C4:  CALL    378
....................  
....................    printf("AT +CIFSR");  
004C8:  MOV     #0,W1
004CA:  MOV     W1,W0
004CC:  CLR.B   1
004CE:  CALL    194
004D2:  INC     W1,W1
004D4:  BTSC.B  219.1
004D6:  BRA     4D4
004D8:  MOV     W0,21A
004DA:  MOV     #8,W0
004DC:  CPSGT   W1,W0
004DE:  BRA     4CA
....................    putc(13,UART_PORT2); 
004E0:  MOV.B   #D,W0L
004E2:  BTSC.B  219.1
004E4:  BRA     4E2
004E6:  MOV.B   W0L,21A
004E8:  CLR.B   21B
....................    delay_ms(500); 
004EA:  MOV     #1F4,W0
004EC:  CALL    378
004F0:  RETURN  
.................... } 
....................  
.................... //*********************CONNCET*************************************** 
.................... void connect(){ 
*
0051C:  MOV     W5,[W15++]
0051E:  MOV     W6,[W15++]
00520:  MOV     W7,[W15++]
....................    //char command[256]; 
....................    char command_con[256], command_client[256]; 
....................    char broker_command[256]; 
....................     
....................    sprintf(broker_command,"AT+CIPSTART=\"TCP\",\"%s\",\"%s\"",BROKER_ADDR,BROKER_PORT); 
00522:  MOV     #AFC,W4
00524:  MOV     W4,8D0
00526:  MOV     #0,W1
00528:  MOV     W1,W0
0052A:  CLR.B   1
0052C:  CALL    1AA
00530:  INC     W1,W1
00532:  MOV     W1,[W15++]
00534:  MOV     W0,[W15++]
00536:  MOV     [--W15],W0
00538:  CALL    4F2
0053C:  MOV     [--W15],W1
0053E:  MOV     #12,W0
00540:  CPSGT   W1,W0
00542:  BRA     528
00544:  MOV     #0,W5
00546:  MOV     W5,W0
00548:  CALL    1D2
0054C:  IOR.B   #0,W0L
0054E:  BTSC.B  42.1
00550:  BRA     55A
00552:  INC     W5,W5
00554:  CALL    4F2
00558:  BRA     546
0055A:  MOV.B   #22,W0L
0055C:  CALL    4F2
00560:  MOV.B   #2C,W0L
00562:  CALL    4F2
00566:  MOV.B   #22,W0L
00568:  CALL    4F2
0056C:  MOV     #0,W6
0056E:  MOV     W6,W0
00570:  CALL    1EE
00574:  IOR.B   #0,W0L
00576:  BTSC.B  42.1
00578:  BRA     582
0057A:  INC     W6,W6
0057C:  CALL    4F2
00580:  BRA     56E
00582:  MOV.B   #22,W0L
00584:  CALL    4F2
....................    printf("%s",broker_command);  
00588:  MOV     #AFC,W1
0058A:  CP0.B   [W1]
0058C:  BRA     Z,59C
0058E:  BTSC.B  219.1
00590:  BRA     58E
00592:  MOV.B   [W1+#0],W0L
00594:  MOV.B   W0L,21A
00596:  CLR.B   21B
00598:  INC     W1,W1
0059A:  BRA     58A
....................    putc(13,UART_PORT2); 
0059C:  MOV.B   #D,W0L
0059E:  BTSC.B  219.1
005A0:  BRA     59E
005A2:  MOV.B   W0L,21A
005A4:  CLR.B   21B
....................    delay_ms(3500); 
005A6:  MOV     #DAC,W0
005A8:  CALL    378
....................    printf("AT+CIPSEND;");  
005AC:  MOV     #0,W1
005AE:  MOV     W1,W0
005B0:  CLR.B   1
005B2:  CALL    200
005B6:  INC     W1,W1
005B8:  BTSC.B  219.1
005BA:  BRA     5B8
005BC:  MOV     W0,21A
005BE:  MOV     #A,W0
005C0:  CPSGT   W1,W0
005C2:  BRA     5AE
....................    putc(13,UART_PORT2); 
005C4:  MOV.B   #D,W0L
005C6:  BTSC.B  219.1
005C8:  BRA     5C6
005CA:  MOV.B   W0L,21A
005CC:  CLR.B   21B
....................    delay_ms(50); 
005CE:  MOV     #32,W0
005D0:  CALL    378
....................    
....................    sprintf(command_con,"%s",(char*)PRO_NAME_CON); 
005D4:  MOV     #5,W3
005D6:  MOV     #0,W2
005D8:  MOV     #BFC,W1
005DA:  MOV     W3,[W15++]
005DC:  MOV     W2,W0
005DE:  CALL    218
005E2:  MOV     [--W15],W3
005E4:  MOV.B   W0L,[W1++]
005E6:  INC     W2,W2
005E8:  DEC     W3,W3
005EA:  BTSS.B  42.1
005EC:  BRA     5DA
005EE:  MOV     #8FC,W4
005F0:  MOV     W4,8D0
005F2:  MOV     #BFC,W1
005F4:  CP0.B   [W1]
005F6:  BRA     Z,608
005F8:  MOV     W1,[W15++]
005FA:  MOV     W1,W4
005FC:  MOV.B   [W4],W0L
005FE:  CALL    4F2
00602:  MOV     [--W15],W1
00604:  INC     W1,W1
00606:  BRA     5F4
....................    sprintf(command_client,"%s",(char*)CLIENT_NAME_CON); 
00608:  MOV     #7,W3
0060A:  MOV     #0,W2
0060C:  MOV     #BFC,W1
0060E:  MOV     W3,[W15++]
00610:  MOV     W2,W0
00612:  CALL    22A
00616:  MOV     [--W15],W3
00618:  MOV.B   W0L,[W1++]
0061A:  INC     W2,W2
0061C:  DEC     W3,W3
0061E:  BTSS.B  42.1
00620:  BRA     60E
00622:  MOV     #9FC,W4
00624:  MOV     W4,8D0
00626:  MOV     #BFC,W1
00628:  CP0.B   [W1]
0062A:  BRA     Z,63C
0062C:  MOV     W1,[W15++]
0062E:  MOV     W1,W4
00630:  MOV.B   [W4],W0L
00632:  CALL    4F2
00636:  MOV     [--W15],W1
00638:  INC     W1,W1
0063A:  BRA     628
....................    printf("%c%c%c%c%s%c%c%c%c%c%c%s%c",(char*)CONTROL_BYTE_CON,(char)(strlen(command_con) + strlen(command_client) + 8),(char*)PRO_NAME_LEN_MSB_CON,(char)strlen((char*)PRO_NAME_CON),command_con,(char*)PRO_TCP_IPV4,(char*)FLAG_CONNCECT,(char*)KEEP_ALIVE_MSB,(char*)KEEP_ALIVE_LSB,(char*)CLIENT_IDEN_LEN_MSB,(char)strlen(command_client),command_client,ENTER);    
0063C:  MOV     #8FC,W4
0063E:  MOV     W4,C08
00640:  CALL    500
00644:  MOV.B   W0L,W5L
00646:  MOV     #9FC,W4
00648:  MOV     W4,C08
0064A:  CALL    500
0064E:  ADD.B   W0L,W5L,W0L
00650:  ZE      W0,W0
00652:  CLR.B   1
00654:  ADD     W0,#8,W0
00656:  MOV.B   W0L,W5L
00658:  MOV     #5,W3
0065A:  MOV     #0,W2
0065C:  MOV     #BFC,W1
0065E:  MOV     W3,[W15++]
00660:  MOV     W2,W0
00662:  CALL    218
00666:  MOV     [--W15],W3
00668:  MOV.B   W0L,[W1++]
0066A:  INC     W2,W2
0066C:  DEC     W3,W3
0066E:  BTSS.B  42.1
00670:  BRA     65E
00672:  MOV     #BFC,W4
00674:  MOV     W4,C08
00676:  CALL    500
0067A:  MOV.B   W0L,W6L
0067C:  MOV     #9FC,W4
0067E:  MOV     W4,C08
00680:  CALL    500
00684:  MOV.B   W0L,W7L
00686:  BTSC.B  219.1
00688:  BRA     686
0068A:  MOV     #10,W4
0068C:  MOV     W4,21A
0068E:  BTSC.B  219.1
00690:  BRA     68E
00692:  PUSH    21A
00694:  MOV.B   W5L,[W15-#2]
00696:  POP     21A
00698:  CLR.B   21B
0069A:  BTSC.B  219.1
0069C:  BRA     69A
0069E:  CLR     21A
006A0:  BTSC.B  219.1
006A2:  BRA     6A0
006A4:  PUSH    21A
006A6:  MOV.B   W6L,[W15-#2]
006A8:  POP     21A
006AA:  CLR.B   21B
006AC:  MOV     #8FC,W1
006AE:  CP0.B   [W1]
006B0:  BRA     Z,6C0
006B2:  BTSC.B  219.1
006B4:  BRA     6B2
006B6:  MOV.B   [W1+#0],W0L
006B8:  MOV.B   W0L,21A
006BA:  CLR.B   21B
006BC:  INC     W1,W1
006BE:  BRA     6AE
006C0:  BTSC.B  219.1
006C2:  BRA     6C0
006C4:  MOV     #4,W4
006C6:  MOV     W4,21A
006C8:  BTSC.B  219.1
006CA:  BRA     6C8
006CC:  MOV     #2,W4
006CE:  MOV     W4,21A
006D0:  BTSC.B  219.1
006D2:  BRA     6D0
006D4:  CLR     21A
006D6:  BTSC.B  219.1
006D8:  BRA     6D6
006DA:  MOV     #3C,W4
006DC:  MOV     W4,21A
006DE:  BTSC.B  219.1
006E0:  BRA     6DE
006E2:  CLR     21A
006E4:  BTSC.B  219.1
006E6:  BRA     6E4
006E8:  PUSH    21A
006EA:  MOV.B   W7L,[W15-#2]
006EC:  POP     21A
006EE:  CLR.B   21B
006F0:  MOV     #9FC,W1
006F2:  CP0.B   [W1]
006F4:  BRA     Z,704
006F6:  BTSC.B  219.1
006F8:  BRA     6F6
006FA:  MOV.B   [W1+#0],W0L
006FC:  MOV.B   W0L,21A
006FE:  CLR.B   21B
00700:  INC     W1,W1
00702:  BRA     6F2
00704:  BTSC.B  219.1
00706:  BRA     704
00708:  MOV     #1A,W4
0070A:  MOV     W4,21A
0070C:  MOV     [--W15],W7
0070E:  MOV     [--W15],W6
00710:  MOV     [--W15],W5
00712:  RETURN  
.................... } 
....................  
.................... //***********************PUBLISH*********************************** 
.................... void send_data(){ 
*
01DCC:  MOV     W5,[W15++]
01DCE:  MOV     W6,[W15++]
01DD0:  MOV     W9,[W15++]
01DD2:  MOV     W10,[W15++]
....................    char command[256]; 
....................    // float tmp1, hum1, ph1, dust1, uv1; 
....................     
....................    // tmp  = 1;                           // Bien nhiet do 
....................    // hum  = 1;                           // Bien do am 
....................    // PH   = 1;                            // Bien pH 
....................    // Dust = 1;                          // Bien bui 
....................    // UV   = 1;                            // Bien Uv 
....................  
....................    UV = read_avg_UV(); 
01DD4:  CALL    10D2
01DD8:  MOV     W0,8BC
01DDA:  MOV     W1,8BE
....................        
....................    //Read TMP AND HUM value 
....................    Start_signal(); 
01DDC:  CALL    11B8
....................    if(!check_response())  
01DE0:  CALL    11D6
01DE4:  CP0.B   W0L
01DE6:  BRA     Z,1DE8
....................    continue; 
....................    RH_Byte1 = Read_Data(); 
01DE8:  CALL    1210
01DEC:  MOV.B   W0L,8B9
....................    RH_Byte2 = Read_Data(); 
01DEE:  CALL    1210
01DF2:  MOV.B   W0L,8BA
....................    T_Byte1  = Read_Data(); 
01DF4:  CALL    1210
01DF8:  MOV.B   W0L,8B7
....................    T_Byte2  = Read_Data();     
01DFA:  CALL    1210
01DFE:  MOV.B   W0L,8B8
....................    Read_Data(); // Checksum  
01E00:  CALL    1210
....................    // byte dau tien Tmp*(FF + 1) + byte thu 2 Tmp;   
....................    tmp = ((float)T_Byte1*256+ (float)T_Byte2) / 10;     
01E04:  MOV.B   8B7,W0L
01E06:  CLR.B   1
01E08:  CALL    A68
01E0C:  MOV     W0,W5
01E0E:  MOV     W1,W6
01E10:  MOV     W5,W0
01E12:  MOV     W6,W1
01E14:  MOV     #0,W2
01E16:  MOV     #4380,W3
01E18:  CALL    AA2
01E1C:  MOV     W0,W5
01E1E:  MOV     W1,W6
01E20:  MOV.B   8B8,W0L
01E22:  CLR.B   1
01E24:  CALL    A68
01E28:  BCLR.B  43.0
01E2A:  MOV     W0,W2
01E2C:  MOV     W1,W3
01E2E:  MOV     W5,W0
01E30:  MOV     W6,W1
01E32:  CALL    B66
01E36:  MOV     W0,W5
01E38:  MOV     W1,W6
01E3A:  MOV     W5,W0
01E3C:  MOV     W6,W1
01E3E:  MOV     #0,W2
01E40:  MOV     #4120,W3
01E42:  CALL    F60
01E46:  MOV     W0,8C8
01E48:  MOV     W1,8CA
....................    hum = ((float)RH_Byte1*256+ (float)RH_Byte2) / 10;    
01E4A:  MOV.B   8B9,W0L
01E4C:  CLR.B   1
01E4E:  CALL    A68
01E52:  MOV     W0,W5
01E54:  MOV     W1,W6
01E56:  MOV     W5,W0
01E58:  MOV     W6,W1
01E5A:  MOV     #0,W2
01E5C:  MOV     #4380,W3
01E5E:  CALL    AA2
01E62:  MOV     W0,W5
01E64:  MOV     W1,W6
01E66:  MOV.B   8BA,W0L
01E68:  CLR.B   1
01E6A:  CALL    A68
01E6E:  BCLR.B  43.0
01E70:  MOV     W0,W2
01E72:  MOV     W1,W3
01E74:  MOV     W5,W0
01E76:  MOV     W6,W1
01E78:  CALL    B66
01E7C:  MOV     W0,W5
01E7E:  MOV     W1,W6
01E80:  MOV     W5,W0
01E82:  MOV     W6,W1
01E84:  MOV     #0,W2
01E86:  MOV     #4120,W3
01E88:  CALL    F60
01E8C:  MOV     W0,8CC
01E8E:  MOV     W1,8CE
....................     
....................    //Read DUST value 
....................    Dust = read_avg_Dust();  
01E90:  CALL    1700
01E94:  MOV     W0,8C0
01E96:  MOV     W1,8C2
....................    if(Dust < 0) Dust = 0; 
01E98:  MOV     8C0,W0
01E9A:  MOV     8C2,W1
01E9C:  MOV     #0,W2
01E9E:  MOV     #0,W3
01EA0:  CALL    9D4
01EA4:  BRA     NC,1EAA
01EA6:  CLR     8C0
01EA8:  CLR     8C2
....................     
....................    //Read PH value 
....................    PH = read_avg_PH(); 
01EAA:  CALL    1A28
01EAE:  MOV     W0,8C4
01EB0:  MOV     W1,8C6
....................     
....................    printf("AT+CIPSEND;");                 // Yeu cau gui du lieu 
01EB2:  MOV     #0,W1
01EB4:  MOV     W1,W0
01EB6:  CLR.B   1
01EB8:  CALL    200
01EBC:  INC     W1,W1
01EBE:  BTSC.B  219.1
01EC0:  BRA     1EBE
01EC2:  MOV     W0,21A
01EC4:  MOV     #A,W0
01EC6:  CPSGT   W1,W0
01EC8:  BRA     1EB4
....................    putc(13,UART_PORT2);  
01ECA:  MOV.B   #D,W0L
01ECC:  BTSC.B  219.1
01ECE:  BRA     1ECC
01ED0:  MOV.B   W0L,21A
01ED2:  CLR.B   21B
....................    delay_ms(500); 
01ED4:  MOV     #1F4,W0
01ED6:  CALL    378
....................    sprintf(command,"%s{\"DEVICE_ID\":\"demo_station\",\"TMP\":%f,\"HUM\":%f,\"UV\":%f,\"DUST\":%f,\"PH\":%f}",(char*)BROKER_TOPIC, tmp, hum, UV, Dust, PH);            // Data publich message 
01EDA:  MOV     #14,W3
01EDC:  MOV     #0,W2
01EDE:  MOV     #9FC,W1
01EE0:  MOV     W3,[W15++]
01EE2:  MOV     W2,W0
01EE4:  CALL    28C
01EE8:  MOV     [--W15],W3
01EEA:  MOV.B   W0L,[W1++]
01EEC:  INC     W2,W2
01EEE:  DEC     W3,W3
01EF0:  BTSS.B  42.1
01EF2:  BRA     1EE0
01EF4:  MOV     #8FC,W4
01EF6:  MOV     W4,8D0
01EF8:  MOV     #9FC,W1
01EFA:  CP0.B   [W1]
01EFC:  BRA     Z,1F0E
01EFE:  MOV     W1,[W15++]
01F00:  MOV     W1,W4
01F02:  MOV.B   [W4],W0L
01F04:  CALL    4F2
01F08:  MOV     [--W15],W1
01F0A:  INC     W1,W1
01F0C:  BRA     1EFA
01F0E:  MOV     #2,W1
01F10:  MOV     W1,W0
01F12:  CLR.B   1
01F14:  CALL    23E
01F18:  INC     W1,W1
01F1A:  MOV     W1,[W15++]
01F1C:  MOV     W0,[W15++]
01F1E:  MOV     [--W15],W0
01F20:  CALL    4F2
01F24:  MOV     [--W15],W1
01F26:  MOV     #23,W0
01F28:  CPSGT   W1,W0
01F2A:  BRA     1F10
01F2C:  MOV     8CA,W2
01F2E:  MOV     8C8,W1
01F30:  MOV     #0,W0
01F32:  CALL    1B0E
01F36:  MOV     #2,W9
01F38:  MOV     #8008,W10
01F3A:  CALL    1C3E
01F3E:  MOV     #26,W1
01F40:  MOV     W1,W0
01F42:  CLR.B   1
01F44:  CALL    23E
01F48:  INC     W1,W1
01F4A:  MOV     W1,[W15++]
01F4C:  MOV     W0,[W15++]
01F4E:  MOV     [--W15],W0
01F50:  CALL    4F2
01F54:  MOV     [--W15],W1
01F56:  MOV     #2C,W0
01F58:  CPSGT   W1,W0
01F5A:  BRA     1F40
01F5C:  MOV     8CE,W2
01F5E:  MOV     8CC,W1
01F60:  MOV     #0,W0
01F62:  CALL    1B0E
01F66:  MOV     #2,W9
01F68:  MOV     #8008,W10
01F6A:  CALL    1C3E
01F6E:  MOV     #2F,W1
01F70:  MOV     W1,W0
01F72:  CLR.B   1
01F74:  CALL    23E
01F78:  INC     W1,W1
01F7A:  MOV     W1,[W15++]
01F7C:  MOV     W0,[W15++]
01F7E:  MOV     [--W15],W0
01F80:  CALL    4F2
01F84:  MOV     [--W15],W1
01F86:  MOV     #34,W0
01F88:  CPSGT   W1,W0
01F8A:  BRA     1F70
01F8C:  MOV     8BE,W2
01F8E:  MOV     8BC,W1
01F90:  MOV     #0,W0
01F92:  CALL    1B0E
01F96:  MOV     #2,W9
01F98:  MOV     #8008,W10
01F9A:  CALL    1C3E
01F9E:  MOV     #37,W1
01FA0:  MOV     W1,W0
01FA2:  CLR.B   1
01FA4:  CALL    23E
01FA8:  INC     W1,W1
01FAA:  MOV     W1,[W15++]
01FAC:  MOV     W0,[W15++]
01FAE:  MOV     [--W15],W0
01FB0:  CALL    4F2
01FB4:  MOV     [--W15],W1
01FB6:  MOV     #3E,W0
01FB8:  CPSGT   W1,W0
01FBA:  BRA     1FA0
01FBC:  MOV     8C2,W2
01FBE:  MOV     8C0,W1
01FC0:  MOV     #0,W0
01FC2:  CALL    1B0E
01FC6:  MOV     #2,W9
01FC8:  MOV     #8008,W10
01FCA:  CALL    1C3E
01FCE:  MOV     #41,W1
01FD0:  MOV     W1,W0
01FD2:  CLR.B   1
01FD4:  CALL    23E
01FD8:  INC     W1,W1
01FDA:  MOV     W1,[W15++]
01FDC:  MOV     W0,[W15++]
01FDE:  MOV     [--W15],W0
01FE0:  CALL    4F2
01FE4:  MOV     [--W15],W1
01FE6:  MOV     #46,W0
01FE8:  CPSGT   W1,W0
01FEA:  BRA     1FD0
01FEC:  MOV     8C6,W2
01FEE:  MOV     8C4,W1
01FF0:  MOV     #0,W0
01FF2:  CALL    1B0E
01FF6:  MOV     #2,W9
01FF8:  MOV     #8008,W10
01FFA:  CALL    1C3E
01FFE:  MOV.B   #7D,W0L
02000:  CALL    4F2
....................    printf("%c%c%c%c%s%c",(char*)CONTROL_BYTE_PUB,(char)(strlen(command) + 2),(char*)PRO_NAME_LEN_MSB_PUB,(char)strlen((char*)BROKER_TOPIC),command,ENTER); 
02004:  MOV     #8FC,W4
02006:  MOV     W4,C08
02008:  CALL    500
0200C:  ZE      W0,W0
0200E:  CLR.B   1
02010:  ADD     W0,#2,W0
02012:  MOV.B   W0L,W5L
02014:  MOV     #14,W3
02016:  MOV     #0,W2
02018:  MOV     #9FC,W1
0201A:  MOV     W3,[W15++]
0201C:  MOV     W2,W0
0201E:  CALL    28C
02022:  MOV     [--W15],W3
02024:  MOV.B   W0L,[W1++]
02026:  INC     W2,W2
02028:  DEC     W3,W3
0202A:  BTSS.B  42.1
0202C:  BRA     201A
0202E:  MOV     #9FC,W4
02030:  MOV     W4,C08
02032:  CALL    500
02036:  MOV.B   W0L,W6L
02038:  BTSC.B  219.1
0203A:  BRA     2038
0203C:  MOV     #30,W4
0203E:  MOV     W4,21A
02040:  BTSC.B  219.1
02042:  BRA     2040
02044:  PUSH    21A
02046:  MOV.B   W5L,[W15-#2]
02048:  POP     21A
0204A:  CLR.B   21B
0204C:  BTSC.B  219.1
0204E:  BRA     204C
02050:  CLR     21A
02052:  BTSC.B  219.1
02054:  BRA     2052
02056:  PUSH    21A
02058:  MOV.B   W6L,[W15-#2]
0205A:  POP     21A
0205C:  CLR.B   21B
0205E:  MOV     #8FC,W1
02060:  CP0.B   [W1]
02062:  BRA     Z,2072
02064:  BTSC.B  219.1
02066:  BRA     2064
02068:  MOV.B   [W1+#0],W0L
0206A:  MOV.B   W0L,21A
0206C:  CLR.B   21B
0206E:  INC     W1,W1
02070:  BRA     2060
02072:  BTSC.B  219.1
02074:  BRA     2072
02076:  MOV     #1A,W4
02078:  MOV     W4,21A
0207A:  MOV     [--W15],W10
0207C:  MOV     [--W15],W9
0207E:  MOV     [--W15],W6
02080:  MOV     [--W15],W5
02082:  RETURN  
.................... } 
....................  
.................... //***********************Debug*************************************** 
.................... void DB_Log (char* log) 
.................... { 
....................    puts(log,UART_PORT1); 
*
00388:  MOV     8FC,W1
0038A:  CP0.B   [W1]
0038C:  BRA     Z,39C
0038E:  BTSC.B  20F.1
00390:  BRA     38E
00392:  MOV.B   [W1+#0],W0L
00394:  MOV.B   W0L,210
00396:  CLR.B   211
00398:  INC     W1,W1
0039A:  BRA     38A
0039C:  BTSC.B  20F.1
0039E:  BRA     39C
003A0:  MOV     #D,W4
003A2:  MOV     W4,210
003A4:  BTSC.B  20F.1
003A6:  BRA     3A4
003A8:  MOV     #A,W4
003AA:  MOV     W4,210
....................    putc(13,UART_PORT2); 
003AC:  MOV.B   #D,W0L
003AE:  BTSC.B  219.1
003B0:  BRA     3AE
003B2:  MOV.B   W0L,21A
003B4:  CLR.B   21B
003B6:  RETURN  
.................... } 
....................  
.................... //***********************MAIN*************************************** 
.................... void main(){ 
*
02084:  MOV     #2780,W15
02086:  MOV     #27FF,W0
02088:  MOV     W0,20
0208A:  NOP     
0208C:  BSET.B  81.7
0208E:  MOV     #8000,W4
02090:  MOV     W4,20C
02092:  MOV     #400,W4
02094:  MOV     W4,20E
02096:  MOV     #C,W4
02098:  MOV     W4,214
0209A:  MOV     #8000,W4
0209C:  MOV     W4,216
0209E:  MOV     #400,W4
020A0:  MOV     W4,218
020A2:  MOV     #C,W4
020A4:  MOV     W4,21E
020A6:  BCLR.B  221.7
020A8:  BCLR.B  2DF.0
020AA:  BSET.B  2DE.7
020AC:  BCLR.B  2DE.6
020AE:  BCLR.B  220.6
020B0:  MOV     #173,W4
020B2:  MOV     W4,222
020B4:  BSET.B  221.7
020B6:  SETM    2A8
020B8:  BRA     2152
020BA:  DATA    80,02,08
020BC:  DATA    00,00,00
020BE:  DATA    C0,06,08
020C0:  DATA    06,00,00
020C2:  DATA    4B,F0,3F
020C4:  DATA    5C,0A,58
020C6:  DATA    F6,3B,8F
020C8:  DATA    00,C0,3C
020CA:  DATA    8B,28,AC
020CC:  DATA    3C,BE,F6
020CE:  DATA    3F,D2,D5
020D0:  DATA    44,16,8C
020D2:  DATA    15,D7,BF
020D4:  DATA    69,00,5A
020D6:  DATA    2E,1B,87
020D8:  DATA    99,3F,9A
020DA:  DATA    5F,AD,4B
020DC:  DATA    91,E4,01
020DE:  DATA    C0,5D,11
020E0:  DATA    2F,92,E4
020E2:  DATA    81,FB,3F
020E4:  DATA    38,DA,91
020E6:  DATA    80,9D,C5
020E8:  DATA    E0,BF,6F
020EA:  DATA    12,C0,B4
020EC:  DATA    C3,09,AB
020EE:  DATA    3F,6B,C1
020F0:  DATA    03,4E,C1
020F2:  DATA    B5,45,BF
020F4:  DATA    F7,40,05
020F6:  DATA    FF,00,5A
020F8:  DATA    EF,3F,F3
020FA:  DATA    A3,E2,F7
020FC:  DATA    D7,FF,01
020FE:  DATA    40,C0,B4
02100:  DATA    FF,05,3C
02102:  DATA    58,FC,3F
02104:  DATA    3B,D3,C0
02106:  DATA    B5,BA,8C
02108:  DATA    E2,3F,39
0210A:  DATA    D3,C7,3D
0210C:  DATA    41,79,B2
0210E:  DATA    3F,87,0D
02110:  DATA    3C,50,D0
02112:  DATA    AF,62,3F
02114:  DATA    30,4B,8D
02116:  DATA    A2,82,AA
02118:  DATA    04,40,09
0211A:  DATA    A0,40,4A
0211C:  DATA    05,76,03
0211E:  DATA    40,EC,9E
02120:  DATA    37,88,A6
02122:  DATA    44,F0,3F
02124:  DATA    8F,12,8D
02126:  DATA    29,9A,5B
02128:  DATA    C7,3F,0E
0212A:  DATA    E0,80,7C
0212C:  DATA    A1,D8,86
0212E:  DATA    3F,29,4B
02130:  DATA    FB,95,C2
02132:  DATA    37,1A,3F
02134:  DATA    00,00,00
02136:  INC     W2,W2
02138:  CP      W2,#1
0213A:  BRA     NZ,2144
0213C:  TBLRDL  [W1],W3
0213E:  TBLRDH  [W1++],W4
02140:  MOV.B   6,W0L
02142:  RETURN  
02144:  CP      W2,#2
02146:  BRA     NZ,214C
02148:  MOV.B   7,W0L
0214A:  RETURN  
0214C:  MOV.B   8,W0L
0214E:  CLR     W2
02150:  RETURN  
02152:  MOV     #0,W6
02154:  MOV     #0,W0
02156:  MOV     W0,32
02158:  MOV     #20BA,W0
0215A:  MOV     W0,W1
0215C:  CLR     W2
0215E:  CALL    2136
02162:  MOV.B   W0L,B
02164:  CALL    2136
02168:  MOV.B   W0L,A
0216A:  CP0     W5
0216C:  BRA     Z,21A0
0216E:  BTSS    W5.F
02170:  BRA     2180
02172:  CALL    2136
02176:  MOV.B   W0L,D
02178:  CALL    2136
0217C:  MOV.B   W0L,C
0217E:  BCLR    W5.F
02180:  BTSS    W5.E
02182:  BRA     2194
02184:  BCLR    W5.E
02186:  DEC     W5,W5
02188:  CALL    2136
0218C:  MOV.B   W0L,W7L
0218E:  REPEAT  W5
02190:  MOV.B   W7L,[W6++]
02192:  BRA     215E
02194:  CALL    2136
02198:  MOV.B   W0L,[W6++]
0219A:  DEC     W5,W5
0219C:  BRA     NZ,2194
0219E:  BRA     215E
....................     
.................... //----Khoi tao Analog---// 
....................    ana_init(); 
021A0:  CALL    36A
....................    delay_ms(1000); 
021A4:  MOV     #3E8,W0
021A6:  CALL    378
....................     
.................... //----Module_SIM-------// 
....................    int dem = 0; 
021AA:  CLR     8D2
....................    DB_Log((char*)"=======JWCLAB START========"); 
021AC:  MOV     #1C,W3
021AE:  MOV     #0,W2
021B0:  MOV     #8D4,W1
021B2:  MOV     W3,[W15++]
021B4:  MOV     W2,W0
021B6:  CALL    2AC
021BA:  MOV     [--W15],W3
021BC:  MOV.B   W0L,[W1++]
021BE:  INC     W2,W2
021C0:  DEC     W3,W3
021C2:  BTSS.B  42.1
021C4:  BRA     21B2
021C6:  MOV     #8D4,W4
021C8:  MOV     W4,8FC
021CA:  CALL    388
....................    AT_Commands(); 
021CE:  CALL    3B8
....................    delay_ms(50); 
021D2:  MOV     #32,W0
021D4:  CALL    378
....................  
....................    DB_Log((char*)"=======JWCLAB CONNECT BROKER========"); 
021D8:  MOV     #25,W3
021DA:  MOV     #0,W2
021DC:  MOV     #8D4,W1
021DE:  MOV     W3,[W15++]
021E0:  MOV     W2,W0
021E2:  CALL    2D4
021E6:  MOV     [--W15],W3
021E8:  MOV.B   W0L,[W1++]
021EA:  INC     W2,W2
021EC:  DEC     W3,W3
021EE:  BTSS.B  42.1
021F0:  BRA     21DE
021F2:  MOV     #8D4,W4
021F4:  MOV     W4,8FC
021F6:  CALL    388
....................     
....................    connect(); 
021FA:  CALL    51C
....................    delay_ms(200); 
021FE:  MOV     #C8,W0
02200:  CALL    378
....................     
....................     
....................    while(TRUE) 
....................    {         
....................       DB_Log((char*)"=======JWCLAB SEND DATA BROKER========"); 
02204:  MOV     #27,W3
02206:  MOV     #0,W2
02208:  MOV     #8D4,W1
0220A:  MOV     W3,[W15++]
0220C:  MOV     W2,W0
0220E:  CALL    306
02212:  MOV     [--W15],W3
02214:  MOV.B   W0L,[W1++]
02216:  INC     W2,W2
02218:  DEC     W3,W3
0221A:  BTSS.B  42.1
0221C:  BRA     220A
0221E:  MOV     #8D4,W4
02220:  MOV     W4,8FC
02222:  CALL    388
....................       send_data();  
02226:  CALL    1DCC
....................       delay_ms(5000); 
0222A:  MOV     #1388,W0
0222C:  CALL    378
....................       dem++; 
02230:  INC     08D2
....................       if(dem == 1000){ 
02232:  MOV     8D2,W4
02234:  XOR     #3E8,W4
02236:  BRA     NZ,22B0
....................           DB_Log((char*)"=======JWCLAB CLOSE BROKER========"); 
02238:  MOV     #23,W3
0223A:  MOV     #0,W2
0223C:  MOV     #8D4,W1
0223E:  MOV     W3,[W15++]
02240:  MOV     W2,W0
02242:  CALL    33A
02246:  MOV     [--W15],W3
02248:  MOV.B   W0L,[W1++]
0224A:  INC     W2,W2
0224C:  DEC     W3,W3
0224E:  BTSS.B  42.1
02250:  BRA     223E
02252:  MOV     #8D4,W4
02254:  MOV     W4,8FC
02256:  CALL    388
....................           printf("AT+CIPCLOSE"); 
0225A:  MOV     #0,W1
0225C:  MOV     W1,W0
0225E:  CLR.B   1
02260:  CALL    100
02264:  INC     W1,W1
02266:  BTSC.B  219.1
02268:  BRA     2266
0226A:  MOV     W0,21A
0226C:  MOV     #A,W0
0226E:  CPSGT   W1,W0
02270:  BRA     225C
....................           putc(13,UART_PORT2); 
02272:  MOV.B   #D,W0L
02274:  BTSC.B  219.1
02276:  BRA     2274
02278:  MOV.B   W0L,21A
0227A:  CLR.B   21B
....................           delay_ms(3000); 
0227C:  MOV     #BB8,W0
0227E:  CALL    378
....................           DB_Log((char*)"=======JWCLAB CONNECT BROKER========"); 
02282:  MOV     #25,W3
02284:  MOV     #0,W2
02286:  MOV     #8D4,W1
02288:  MOV     W3,[W15++]
0228A:  MOV     W2,W0
0228C:  CALL    2D4
02290:  MOV     [--W15],W3
02292:  MOV.B   W0L,[W1++]
02294:  INC     W2,W2
02296:  DEC     W3,W3
02298:  BTSS.B  42.1
0229A:  BRA     2288
0229C:  MOV     #8D4,W4
0229E:  MOV     W4,8FC
022A0:  CALL    388
....................           connect();delay_ms(50); 
022A4:  CALL    51C
022A8:  MOV     #32,W0
022AA:  CALL    378
....................           dem = 0; 
022AE:  CLR     8D2
....................       }     
022B0:  GOTO    2204
....................    } 
.................... } 
022B4:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 0304   XT PR CKSFSM
          H: FF00  
   Word  2L: 003F   WPSB16 WPSA512 NOWDT
          H: FF00  
   Word  3L: 8033   PUT64 BORRES NOBROWNOUT MCLR
          H: FF00  
   Word  4L: 310F  
          H: FF00  
   Word  5L: 330F  
          H: FF00  
   Word  6L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  7L: C003   ICSP1 NODEBUG
          H: FF00  
